# Going Further with the Unix Shell {#py-rse-bash-advanced}

```{r py-rse-bash-advanced-setup, include=FALSE}
source(here::here("_common.R"))
```

Chapter \@ref(py-rse-bash-basics) explained how we can use the command line
to do all of the things we can do with a graphical file explorer,
and how to go beyond that to combine commands in powerful ways using pipes and redirection.
This chapter extends those ideas to show how we can save commands in files
to create new tools of our own,
and how to use a more powerful version of [wildcards][wildcard]
to extract data from files.

We'll be continuing to work in `zipfs_law/`,
which after the previous chapter should contain the following files:

```text
└── data
    ├── README.md
    ├── dracula.txt
    ├── frankenstein.txt
    ├── jane_eyre.txt
    ├── moby_dick.txt
    ├── sense_and_sensibility.txt
    ├── sherlock_holmes.txt
    └── time_machine.txt
```

> **Deleting Extra Files**
>
> If you worked through all of the exercises in the previous chapter,
> you may have additional files present,
> but we won't be using them for the rest of the book.
> Feel free to delete or move these files to a separate directory.
> We'll include a summary like this at the beginning of each chapter
> to ensure you have *at least* the essential files present.
> If you've accidentally deleted an essential file,
> feel free to download it again from FIXME.

## How can I create new commands of my own? {#py-rse-bash-advanced-script}

Loops and history let us do tasks repeatedly,
but we can go even further and save commands in files
so that we can re-run complex sequences of operations with a few keystrokes.
For historical reasons,
a file full of shell commands is usually called a [shell script][shell-script],
but it is really just another kind of program.

Let's start by ensuring our working directory is `zipfs_law`,
and creating a new file called `book_summary.sh`
to hold our shell script:

```shell
$ cd ~/zipfs_law
$ nano book_summary.sh
```

Insert this line:

```text
head -n 19 data/moby_dick.txt | tail -n 11
```

Note that we do *not* put a dollar sign `$` at the front of the line:
we have been showing that for interactive commands,
but in this case we are putting the command in a file rather than running it immediately.

Once we have added this line to the file,
we can write it out with <kbd>Ctrl</kbd>+<kbd>O</kbd>
and exit with <kbd>Ctrl</kbd>+<kbd>O</kbd>.
`ls` shows that our file now exists:

```shell
$ ls
```

```text
book_summary.sh	  data/
```

We can view the contents of the file using `cat book_summary.sh`.
More importantly,
we can now ask the shell to run this file:

```shell
$ bash book_summary.sh
```

```text

Title: Moby Dick
       or The Whale
Author: Herman Melville
Editor:
Release Date: December 25, 2008 [EBook #2701]
Posting Date:
Last Updated: December 3, 2017
Language: English
Character set encoding: UTF-8

```

Sure enough,
our script's output is exactly what we would get if we ran the command directly.
For example,
we can count how many lines of output there are by putting our script in a pipeline:

```shell
$ bash book_summary.sh | wc -l
```

```text
    11
```

What if we want to extract the name of the author?

We'll need to modify our script:

```shell
$ nano book_summary.sh
```

The command `grep` searches for every line that contains a pattern and prints the matching lines.
We'll learn more about `grep` in Section \@ref(py-rse-bash-advanced-grep),
but for now we can edit the script to add a search for the word "Author":

```text
head -n 19 data/moby_dick.txt | tail -n 11 | grep Author
```

Let's finally run the modified script:

```shell
$ bash book_summary.sh
```

```text
Author: Herman Melville
```

Once again,
we can pipe the output of our script into other commands
just as we would pipe the output from any other program:

```shell
$ bash book_summary.sh | wc -w
```

```text
      3
```

## How can I make my scripts more versatile? {#py-rse-bash-advanced-params}

Getting the name of the author for only one of the books isn't all that useful.
What we really want is a way to get the name of the author from any of our files.
Let's edit `book_summary.sh` again and replace `data/moby_dick.txt`
with a special variable `$1`.
Once our change is made,
`book_summary.sh` should contain:

```text
head -n 19 $1 | tail -n 11 | grep Author
```

Inside a shell script,
`$1` means "the first argument on the command line".
We can now run our script like this:

```shell
$ bash book_summary.sh data/moby_dick.txt
```

and get exactly the same output as before,
or give it a different filename:

```shell
$  bash book_summary.sh data/frankenstein.txt
```

and get the author name for that book instead.

```text
Author: Mary Wollstonecraft (Godwin) Shelley
```

Our small script is now doing something useful,
but it may take the next person who reads it a moment to figure out exactly what that is.
We can improve our script by adding [comments][comment] at the top:

```text
# Get author information from a Project Gutenberg eBook.
# Usage: bash book_summary.sh /path/to/file.txt
head -n 19 $1 | tail -n 11 | grep Author
```

As in R and Python,
a comment starts with a `#` character and runs to the end of the line.
The computer ignores comments,
but they help people (including our future self) understand and use scripts.

Let's make one more change to our script.
Instead of always extracting the author name,
let's have it select whatever information the user specified:

```text
# Get desired information from a Project Gutenberg eBook.
# Usage: bash book_summary.sh /path/to/file.txt
head -n 19 $1 | tail -n 11 | grep $2
```

The change is very small:
we have replaced the fixed string 'Author' with a reference to the special variable `$2`,
which is assigned the value of the second command-line argument we give the script when we run it.

> **Update Your Comments**
>
> As you update the code in your script,
> don't forget to update the comments that describe the code.
> A description that sends readers in the wrong direction is worse than none at all,
> so do your best to avoid this common oversight.

Let's check that it works by asking for 'Release Date':

```shell
$ bash book_summary.sh data/frankenstein.txt Release Date
```

```text
Release Date: June 17, 2008 [EBook #84]
```

## How can I turn interactive work into a script? {#py-rse-bash-advanced-capture}

Suppose we have just run a series of commands that did something useful,
such as summarizing all books in a given directory.
Instead of typing those commands into a file in an editor
(and potentially getting them wrong)
we can run the following command to save the six most recent commands in `summarize_all_books.sh`:

```shell
$ history 5 > summarize_all_books.sh
$ cat summarize_all_books.sh
```

```text
297 for x in data/*.txt; do echo $x; bash book_summary.sh $x Author; done > authors.txt
298 for x in data/*.txt; do echo $x; bash book_summary.sh $x Release Data; done > releases.txt
299 ls
300 mkdir summaries
301 mv authors.txt releases.txt summaries
302 history 6 > summarize_all_books.sh
```

Open the file in an editor,
remove the serial numbers at the start of each line,
and delete the extraneous lines (`ls` and the last line),
and you've created a script that accurately and efficiently captures what we actually did.

This is how we usually develop shell scripts:
run commands interactively a few times to make sure they are doing the right thing,
then save our recent history to a file and turn that into a reusable script.

## How can I find things in a file? {#py-rse-bash-advanced-grep}

We can use `head` and `tail` to select lines from a file by position,
but we also often want to select lines that contain certain values.
This operation is called [filtering][filter] When we are working with database tables or dataframes,
and in the shell,
we usually do it by the command `grep` that we already used before.
The name comes from "global regular expression print",
which was a common sequence of operations in early Unix text editors.
To show more on how `grep` works,
we will use our sleuthing skills to explore `data/sherlock_holmes.txt`.

Let's find lines that contain the word "Sherlock".
Since we're searching the entire text of a book,
we'll pipe to `head` so that only the first few lines are shown
(`-n 5` means the first five results will be printed):

```shell
$ grep Sherlock data/sherlock_holmes.txt | head -n 5
```

```text
Project Gutenberg's The Adventures of Sherlock Holmes, by Arthur Conan Doyle
Title: The Adventures of Sherlock Holmes
To Sherlock Holmes she is always THE woman. I have seldom heard
as I had pictured it from Sherlock Holmes' succinct description,
"Good-night, Mister Sherlock Holmes."
```

Here, `Sherlock` is our (very simple) pattern.
`grep` searches the file line by line
and shows those lines that contain matches.

A search for `grep sherlock`
would yield no results, but also no error:
as with other Unix commands,
grep searches are case-sensitive.
If we wanted to make the search case-insensitive,
we could add the option `-i`:

```shell
$ grep -i sherlock data/sherlock_holmes.txt | head -n 5
```

```text
Project Gutenberg's The Adventures of Sherlock Holmes, by Arthur Conan Doyle
Title: The Adventures of Sherlock Holmes
*** START OF THIS PROJECT GUTENBERG EBOOK THE ADVENTURES OF SHERLOCK HOLMES ***
THE ADVENTURES OF SHERLOCK HOLMES
To Sherlock Holmes she is always THE woman. I have seldom heard
```

Note that these results are not quite identical to our previous search,
due to the presence of "SHERLOCK" near the top of the text file.

Next, let's search for the pattern `on`:

```shell
$ grep on data/sherlock_holmes.txt | head -n 5
```

```text
Project Gutenberg's The Adventures of Sherlock Holmes, by Arthur Conan Doyle
This eBook is for the use of anyone anywhere at no cost and with
almost no restrictions whatsoever.  You may copy it, give it away or
with this eBook or online at www.gutenberg.net
Author: Arthur Conan Doyle
```

In each of these five results,
our pattern ("on") is part of a larger word,
such as "Conan".
To restrict matching to lines containing `on` on its own,
we can give `grep` the `-w` option:

```shell
$ grep -w on data/sherlock_holmes.txt
```

```text
One night--it was on the twentieth of March, 1888--I was
put on seven and a half pounds since I saw you."
that I had a country walk on Thursday and came home in a dreadful
"It is simplicity itself," said he; "my eyes tell me that on the
on the right side of his top-hat to show where he has secreted
```

What if we want to search for a phrase rather than a single word?

```shell
$ grep on the data/sherlock_holmes.txt | head -n 5
```

```text
grep: the: No such file or directory
data/sherlock_holmes.txt:﻿Project Gutenberg's The Adventures of Sherlock Holmes, by Arthur Conan Doyle
data/sherlock_holmes.txt:This eBook is for the use of anyone anywhere at no cost and with
data/sherlock_holmes.txt:almost no restrictions whatsoever.  You may copy it, give it away or
data/sherlock_holmes.txt:with this eBook or online at www.gutenberg.net
data/sherlock_holmes.txt:Author: Arthur Conan Doyle
```

In this case,
`grep` uses `on` as the pattern
and tries to find it in the files `the` and `data/sherlock_holmes.txt`.
It then tells us that the file `the` cannot be found,
but prints `data/sherlock_holmes.txt` as a prefix to each other line of output
to tell us which file those lines came from.

If we want to give `grep` both words as a single argument,
we must wrap them in quotation marks:

```shell
$ grep "on the" data/sherlock_holmes.txt
```

```text
One night--it was on the twentieth of March, 1888--I was
drug-created dreams and was hot upon the scent of some new
"It is simplicity itself," said he; "my eyes tell me that on the
on the right side of his top-hat to show where he has secreted
pink-tinted note-paper which had been lying open upon the table.
```

> **Quoting**
>
> Quotation marks aren't specific to `grep`:
> the shell interprets them before running the command,
> just as it expands wildcards to create actual filenames
> no matter what we're asking it to do.
> This allows us to do things like `head -n 5 "My Thesis.txt"`
> if we want to edit a file that has a space in its name.
> It is also why many programmers write `"$variable"` instead of just `$variable`
> when creating loops or shell scripts:
> if there's any chance at all that the variable's value will contain spaces,
> it's safest to quote it.

One of the most useful options for `grep` is `-n`,
which numbers the lines that match the search:

```shell
$ grep -n "on the" data/sherlock_holmes.txt
```

```text
105:One night--it was on the twentieth of March, 1888--I was
118:drug-created dreams and was hot upon the scent of some new
155:"It is simplicity itself," said he; "my eyes tell me that on the
165:on the right side of his top-hat to show where he has secreted
198:pink-tinted note-paper which had been lying open upon the table.
```

`grep` has many options—-
so many,
in fact,
that almost every letter of the alphabet means something to it:

```shell
$ man grep
```

```text
GREP(1)                   BSD General Commands Manual                  GREP(1)

NAME
     grep, egrep, fgrep, zgrep, zegrep, zfgrep -- file pattern searcher

SYNOPSIS
     grep [-abcdDEFGHhIiJLlmnOopqRSsUVvwxZ] [-A num] [-B num] [-C[num]]
          [-e pattern] [-f file] [--binary-files=value] [--color[=when]]
          [--colour[=when]] [--context[=num]] [--label] [--line-buffered]
          [--null] [pattern] [file ...]
...more...
```

We can combine options (i.e. flags) as we do with other Unix commands.
For example,
we can combine two options we've covered previously with a new option,
`-v`,
which inverts the match—-
i.e., prints lines that *don't* match the pattern:

```shell
$ grep -i -n -v the data/sherlock_holmes.txt
```

```text
2:
4:almost no restrictions whatsoever.  You may copy it, give it away or
6:with this eBook or online at www.gutenberg.net
7:
8:
```

As we learned in Chapter \@ref(py-rse-bash-basics),
we can also condense this search as `grep -inv`.

If we want to search several files at once,
all we have to do is give `grep` all of their names.
In these cases,
we can use wildcards,
such as to count how many lines in all of the books contain "pain":

```shell
$ grep pain data/*.txt | wc -l
```

```text
    334
```

Finally,
the `-r` option (for "recursive") tells `grep` to search all of the files
in or below a directory:

```shell
$ grep -r pain data | wc -l
```

```text
      334
```

`grep` becomes even more powerful through the use of [regular expressions][regular-expression],
which are specialized sets of letters, numbers, and symbols
that allow searches for specific patterns.
For example,
this command finds lines that start with the letter 'T':

```shell
$ grep -E "^T" data/sherlock_holmes.txt
```

```text
This eBook is for the use of anyone anywhere at no cost and with
Title: The Adventures of Sherlock Holmes
THE ADVENTURES OF SHERLOCK HOLMES
To Sherlock Holmes she is always THE woman. I have seldom heard
The distinction is clear. For example, you have frequently seen
```

The `-E` option tells `grep` to interpret the pattern as a regular expression,
rather than searching for the specific term provided.
The quotation marks prevent the shell from treating any special characters in the pattern as wildcards,
and the `^` means that a line only matches if it begins with the search term--
in this case, `T`.

Many tools support regular expressions:
we can use them in programming languages,
database queries,
online search engines,
and most text editors (though not Nano—its creators wanted to keep it as small as possible).
A detailed guide of regular expressions is outside the scope of this learning material,
but a wide range of tutorials are available online;
@Goyv2012 is a useful companion if you need to go further.

## How can I find files? {#py-rse-bash-advanced-find}

While `grep` finds things in files,
the `find` command finds files themselves.
It also has a lot of options,
but unlike most Unix commands these are written as full words rather than abbreviations.
To show how it works,
we will use the entire contents of our `zipfs_law` directory,
including files we created earlier in this chapter:

├── book_summary.sh
├── data
│   ├── README.md
│   ├── dracula.txt
│   ├── frankenstein.txt
│   ├── jane_eyre.txt
│   ├── moby_dick.txt
│   ├── sense_and_sensibility.txt
│   ├── sherlock_holmes.txt
│   └── time_machine.txt
├── summaries
│   ├── authors.txt
│   └── releases.txt
└── summarize_all_books.sh

For our first command,
let's run `find .` to find and list everything in this directory.
(As always,
`.` on its own means the current working directory,
which is where we want our search to start.)

```shell
$ find .
```

```text
.
./summarize_all_books.sh
./book_summary.sh
./summaries
./summaries/releases.txt
./summaries/authors.txt
./data
./data/moby_dick.txt
./data/sense_and_sensibility.txt
./data/sherlock_holmes.txt
./data/time_machine.txt
./data/frankenstein.txt
./data/README.md
./data/dracula.txt
./data/jane_eyre.txt
```

If we only want to find directories,
we can tell `find` to show us things of type `d`:

```shell
$ find . -type d
```

```text
.
./summaries
./data
```

If we change `-type d` to `-type f`
we get a listing of all the files instead:

```shell
$ find . -type f
```

```text
./summarize_all_books.sh
./book_summary.sh
./summaries/releases.txt
./summaries/authors.txt
./data/moby_dick.txt
./data/sense_and_sensibility.txt
./data/sherlock_holmes.txt
./data/time_machine.txt
./data/frankenstein.txt
./data/README.md
./data/dracula.txt
./data/jane_eyre.txt
```

Now let's try matching by name:

```shell
$ find . -name "*.txt"
```

```text
./summaries/releases.txt
./summaries/authors.txt
./data/moby_dick.txt
./data/sense_and_sensibility.txt
./data/sherlock_holmes.txt
./data/time_machine.txt
./data/frankenstein.txt
./data/dracula.txt
./data/jane_eyre.txt
```

As stated earlier,
the command line's power lies in combining tools.
We have seen how to do that with pipes;
let's use another technique to see how large our HTML files are:

```shell
$ wc -l $(find . -name "*.txt")
```

```text
14 ./summaries/releases.txt
14 ./summaries/authors.txt
22331 ./data/moby_dick.txt
13028 ./data/sense_and_sensibility.txt
13053 ./data/sherlock_holmes.txt
3582 ./data/time_machine.txt
7832 ./data/frankenstein.txt
15975 ./data/dracula.txt
21054 ./data/jane_eyre.txt
96883 total
```

When the shell executes this command,
it runs whatever is inside the `$()`
and then replaces `$()` with that command's output.
Since the output of `find` is the paths of four HTML files,
the shell constructs the command:

```shell
$ wc -l ./summaries/releases.txt ./summaries/authors.txt ./data/moby_dick.txt ./data/sense_and_sensibility.txt ./data/sherlock_holmes.txt ./data/time_machine.txt ./data/frankenstein.txt ./data/dracula.txt ./data/jane_eyre.txt
```

This results in the output as seen above.
It is exactly like expanding the wildcard in `*.txt`,
but more flexible.

We will often use `find` and `grep` together.
The first finds files whose names match a pattern,
while the second looks for lines inside those files that match another pattern.
For example,
we can look for Authors in all our text files:

```shell
$ grep "Author:" $(find . -name "*.txt")
```

```text
./summaries/authors.txt:Author: Bram Stoker
./summaries/authors.txt:Author: Mary Wollstonecraft (Godwin) Shelley
./summaries/authors.txt:Author: Charlotte Bronte
./summaries/authors.txt:Author: Herman Melville
./summaries/authors.txt:Author: Jane Austen
./summaries/authors.txt:Author: Arthur Conan Doyle
./summaries/authors.txt:Author: H. G. Wells
./data/moby_dick.txt:Author: Herman Melville
./data/sense_and_sensibility.txt:Author: Jane Austen
./data/sherlock_holmes.txt:Author: Arthur Conan Doyle
./data/time_machine.txt:Author: H. G. Wells
./data/frankenstein.txt:Author: Mary Wollstonecraft (Godwin) Shelley
./data/dracula.txt:Author: Bram Stoker
./data/jane_eyre.txt:Author: Charlotte Bronte
```

We can also use `$()` expansion to create a list of filenames to use in a loop:

```shell
$ for file in $(find . -name "*.txt")
> do
> cp $file $file.bak
> done
$ find . -name "*.bak"
```

```text
./summaries/releases.txt.bak
./summaries/authors.txt.bak
./data/frankenstein.txt.bak
./data/sense_and_sensibility.txt.bak
./data/dracula.txt.bak
./data/time_machine.txt.bak
./data/moby_dick.txt.bak
./data/jane_eyre.txt.bak
./data/sherlock_holmes.txt.bak
```

## How can I change the shell's settings? {#py-rse-bash-advanced-vars}

The shell is just a program, and like other programs, it has variables.
Those variables control its execution,
so by changing their values
we can change how the shell and other programs behave.

Let's run the command `set` and look at some of the variables in a typical shell session:

```shell
$ set
```

```text
COMPUTERNAME=TURING
HOME=/Users/amira
HOMEDRIVE=C:
HOSTNAME=TURING
HOSTTYPE=i686
NUMBER_OF_PROCESSORS=4
OS=Windows_NT
PATH=/Users/amira/bin:/usr/local/git/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin
PWD=/Users/amira
UID=1000
USERNAME=amira
...
```

There are quite a few—many more than are shown here.
And yes,
using `set` to *show* things might seem a little strange,
even for Unix,
but if we don't give it any arguments,
it might as well show us things we *could* set.

Every variable has a name.
By convention, variables that are always present are given upper-case names.
All shell variables' values are strings, even those (like `UID`) that look like numbers.
It's up to programs to convert these strings to other types when necessary.
For example, if a program wanted to find out how many processors the computer had,
it would convert the value of the `NUMBER_OF_PROCESSORS` variable from a string to an integer.

Similarly, some variables (like `PATH`) store lists of values.
In this case, the convention is to use a colon ':' as a separator.
If a program wants the individual elements of such a list,
it's the program's responsibility to split the variable's string value into pieces.

Let's have a closer look at `PATH`.
Its value defines the shell's [search path][search-path],
i.e., the list of directories that the shell looks in for runnable programs
when we type in a program name without specifying what directory it is in.

For example,
when we type a command like `analyze`,
the shell needs to decide whether to run `./analyze` (in our current directory)
or `/bin/analyze` (in a system directory).
The rule it uses is simple:
the shell checks each directory in the `PATH` variable in turn,
looking for a program with the requested name in that directory.
As soon as it finds a match, it stops searching and runs the program.

To show how this works,
here are the components of `PATH` listed one per line:

```shell
/Users/amira/bin
/usr/local/git/bin
/usr/bin
/bin
/usr/sbin
/sbin
/usr/local/bin
```

Suppose that our computer has three programs called `analyze`:
`/bin/analyze`,
`/usr/local/bin/analyze`,
and `/Users/amira/analyze`.
Since the shell searches the directories in the order they're listed in `PATH`,
it finds `/bin/analyze` first and runs that.
Since `/Users/amira` is not in our path,
Bash will *never* find the program `/Users/amira/analyze`
unless we type the path in explicitly
(for example,
as `./analyze` if we are in `/Users/amira`).

Let's show the value of the variable `HOME`:

```shell
$ echo HOME
```

```text
HOME
```

Whoops: this just prints "HOME", which isn't what we wanted
(though it is what we asked for).
Let's try this instead:

```shell
$ echo $HOME
```

```text
/Users/amira
```

The dollar sign tells the shell that we want the value of the variable named `HOME`;
as we have seen,
`echo` simply prints the literal string `HOME` if we omit it
(because that's what we want `echo` to do if we type `echo hello` or something similar).
This works just like wildcards:
the shell does the replacement before running the program we've asked for.
Thanks to this expansion, what we actually run is `echo /Users/amira`,
which displays the right thing.

Creating a variable is easy—we just assign a value to a name using "=",
and put quotes around the value if it contains spaces or special characters:

```shell
$ DEPARTMENT="Library Science"
$ echo $DEPARTMENT
```

```text
Library Science
```

To change the value, we just assign a new one:

```shell
$ DEPARTMENT="Information Science"
$ echo $DEPARTMENT
```

```text
Information Science
```

If we want to set some variables automatically every time we run a shell,
we can put commands to do this in a file called `.bashrc` in our home directory.
(The '.' character at the front prevents `ls` from listing this file
unless we specifically ask it to using `-a`.
The "rc" at the end is an abbreviation for "run commands",
which meant something really important decades ago,
and is now just a convention everyone follows without understanding why.)
For example,
here are two lines in `/Users/amira/.bashrc`:

```text
export DEPARTMENT="Library Science"
export TEMP_DIR=/tmp
export BACKUP_DIR=$TEMP_DIR/backup
```

These three lines create the variables `DEPARTMENT`,
`TEMP_DIR`,
and `BACKUP_DIR`,
and export them so that any programs the shell runs can see them as well.
Notice that `BACKUP_DIR`'s definition relies on the value of `TEMP_DIR`,
so that if we change where we put temporary files,
our backups will be relocated automatically.

While we're here,
it's also common to use the `alias` command to create shortcuts for things we frequently type.
For example, we can define the alias `backup`
to run `/bin/zback` with a specific set of arguments:

```shell
alias backup=/bin/zback -v --nostir -R 20000 $HOME $BACKUP_DIR
```

Aliases can save us a lot of typing, and hence a lot of typing mistakes.
The name of an alias can be the same as an existing command,
so we can use them to change the behavior of a familiar command:

```shell
# Long list format including hidden files
alias ls='ls -la'

# Print the file paths that were copied/moved
alias mv='mv -v'
alias cp='cp -v'

# Request confirmation to remove a file and
# print the file path that is removed
alias rm='rm -iv'
```

We can find interesting suggestions for other aliases
by searching online for "sample bashrc".

Demonstrating concepts in this chapter has resulted
in a number of extraneous files that we won't use anymore.
We can use these files to explore how our aliases work in practice,
while cleaning up our project in preparation for our next chapter.

```shell
$ for file in $(find . -name "*.bak")
> do
> rm $file
> done
$ mkdir bin
$ mv book_summary.sh bin
$ rm -r summaries
```

We'll talk more about organizing files associated with projects in Chapter \@ref(py-rse-project),
but will continue setting up our files in an appropriate directory structure until then.

## Summary {#py-rse-bash-advanced-summary}

FIXME: summarize advanced Bash.

## Exercises {#py-rse-bash-advanced-exercises}

Many of the exercises below have been adapted from Software Carpentry's lesson
[The Unix Shell](http://swcarpentry.github.io/shell-novice/).

As with the previous chapter,
extra files and directories created during these exercises may need to be removed from your Zipf's Law project.
We include an overview of the status of the project at the start of the next chapter.

### Variables in shell scripts {#py-rse-bash-advanced-ex-script-variables}

Imagine you have a shell script called `script.sh` containing the
following commands:

```shell
head -n $2 $1
tail -n $3 $1
```

With this script in your `data` directory, you type the following command:

```shell
bash script.sh '*.txt' 1 1
```

Which of the following outputs would you expect to see?

1. All of the lines between the first and the last lines of each file ending in `.txt`
    in the `data` directory
2. The first and the last line of each file ending in `.txt` in the `data` directory
3. The first and the last line of each file in the `data` directory
4. An error because of the quotes around `*.txt`

### Find the longest file with a given extension {#py-rse-bash-advanced-ex-longest-with-extension}

Write a shell script called `longest.sh` that takes the name of a
directory and a filename extension as its arguments, and prints
out the name of the file with the most lines in that directory
with that extension. For example:

```shell
$ bash longest.sh data/ txt
```

would print the name of the `.txt` file in `data` that has
the most lines.

### Script reading comprehension {#py-rse-bash-advanced-ex-reading-scripts}

For this question, consider your `data` directory once again.

Explain what each of the following three scripts would do when run as
`bash script1.sh *.txt`, `bash script2.sh *.txt`, and `bash script3.sh *.txt` respectively.

```shell
# Script 1
echo *.*
```

```shell
# Script 2
for filename in $1 $2 $3
> do
>     cat $filename
> done
```

```shell
# Script 3
echo $@.txt
```

### Using `grep` {#py-rse-bash-advanced-ex-using-grep}

Assume the following text from The Adventures of Sherlock Holmes
is contained within a file called `excerpt.txt`:

```text
To Sherlock Holmes she is always THE woman. I have seldom heard
him mention her under any other name. In his eyes she eclipses
and predominates the whole of her sex. It was not that he felt
any emotion akin to love for Irene Adler.
```

Which of the following commands would provide the following output:

```text
and predominates the whole of her sex. It was not that he felt
```

1. `grep "he" excerpt.txt`
2. `grep -E "he" excerpt.txt`
3. `grep -w "he" excerpt.txt`
4. `grep -i "he" excerpt.txt`

### Tracking publication years {#py-rse-bash-advanced-ex-tracking-species}

In the previous chapter's exercises,
you examined a command that extracted the publication year from a list of book titles (\@ref(py-rse-bash-basics-ex-pipe-construction)).

Write a shell script called `year.sh` that takes any number of
filenames as command-line arguments,
and uses a variation of that command to print a list
of the unique publication years appearing in each of those files separately.

### Counting names {#py-rse-bash-advanced-ex-sense-sensibility}

You and your friend,
having just finished reading *Sense and Sensibility*,
are having an argument.  
Your friend thinks that the elder of the two Dashwood sisters,
Harriet, was mentioned more frequently in the book.
You, however, are certain it was the younger sister, Marianne.  
Luckily, you have a file `sense_and_sensibility.txt` containing the full text of the novel.
Using a `for` loop, how would you tabulate the number of times each
of the sisters is mentioned?

Hint: one solution might employ
the commands `grep` and `wc` and a `|`, while another might utilize
`grep` options.
There is often more than one way to solve a programming task, so a
particular solution is usually chosen based on a combination of
yielding the correct result, elegance, readability, and speed.

### Matching and subtracting {#py-rse-bash-advanced-ex-match-subtract}

Assume your working directory is the root directory of your Zipf's Law project.
Which of the following commands will find all files in `data` whose names end in `e.txt`,
but do *not* contain the word `machine`?

1.  `find data -name '*e.txt' | grep -v machine`
2.  `find data -name *e.txt | grep -v machine`
3.  `grep -v "machine" $(find data -name '*e.txt')`
4.  None of the above.

### `find` pipeline reading comprehension {#py-rse-bash-advanced-ex-reading-find}

Write a short explanatory comment for the following shell script:

```shell
wc -l $(find . -name '*.dat') | sort -n
```

### Finding files with different properties {#py-rse-bash-advanced-ex-find-properties}

The `find` command can be given several other criteria known as "tests"
to locate files with specific attributes, such as creation time, size,
permissions, or ownership.  Use `man find` to explore these, and then
write a single command to find all files in or below the current directory
that are owned by the user `ahmed` and were modified in the last 24 hours.

Hint 1: you will need to use three tests: `-type`, `-mtime`, and `-user`.

Hint 2: The value for `-mtime` will need to be negative—why?

### Combining options {#py-rse-bash-advanced-ex-combining-options}

In some command line tools,
multiple options can be combined with a single `-` and no spaces between the options,
so that (for example) `ls -Fal` is equivalent to `ls -F -a -l`.
Should you use this or not?

### Other wildcards {#py-rse-bash-advanced-ex-other-wildcards}

The shell provides several wildcards beyond the widely-used `*`.
To explore them,
explain in plain language what files the expression `novel-????-[ab]*.{txt,pdf}` matches and why.

## Key Points {#py-rse-bash-advanced-keypoints}

```{r, child="keypoints/rse-bash-advanced.md"}
```

```{r, child="./links.md"}
```
