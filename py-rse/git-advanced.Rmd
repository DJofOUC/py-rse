# Advanced Git {#py-rse-git-advanced}

```{r py-rse-git-advanced-setup, include=FALSE}
source(here::here("_common.R"))
```

Now that we are comfortable using Git at the command line,
we can look at two tools for organizing our development and working with others:
branching and pull requests.
[Branches][git-branch] let us work on multiple things simultaneously in a single repository;
[pull requests][pull-request] (PRs) let us submit our work for review,
get feedback,
and make updates.
Used together,
they allow us to go through the write-review-revise cycle
familiar to anyone who has ever written a journal paper
in hours rather than weeks.

> This lesson is derived in part from one created at
> [the University of Wisconsin-Madison][uwm-git-lesson].
> We are grateful to its authors for using an open license
> so that we could repurpose their work.

Your `zipf` project directory should now include:

```text
├── bin
│   ├── book_summary.sh
│   ├── countwords.py
│   ├── collate.py
│   ├── plotcounts.py
│   └── mymodule.py
├── data
│   ├── README.md
│   ├── dracula.txt
│   ├── frankenstein.txt
│   └── ...
└── results
    ├── dracula.csv
    ├── dracula.png
    ├── jane_eyre.csv
    ├── jane_eyre.png
    └── moby_dick.csv
```

All of these files should also be tracked in your version history.
We'll use these files and some additional analyses to explore both Zipf's Law and some additional Git workflows.

## What is branching and when is it useful? {#py-rse-git-advanced-branch-what}

So far our Git lessons have all used a sequential timeline:
each change builds on the one before,
and *only* on the one before.
However,
there are times when we want to keep our main work safe from experimental changes.
To do this, we can use branches to work on separate tasks in parallel.

We can see what branches have been created in a given repository using this command:

```shell
$ git branch
```

```text
* master
```

When we initialize a repository,
Git automatically creates a branch called `master`.
It is often considered the "official" version of the repository.
The asterisk `*` indicates that it is currently active,
i.e.,
that all changes we make will take place in this branch by default.
(The active branch is like the [current working directory][current-working-directory] in the shell.)

In the previous chapter,
we foreshadowed some experimental changes that we could try and make to `plotcounts.py`.

```shell
$ cat plotcounts.py
```

```python
"""Plot word counts."""
import argparse
import pandas as pd


def main(args):
    """Run the command line program."""
    df = pd.read_csv(args.infile, header=None, names=('word', 'word_frequency'))
    df['rank'] = df['word_frequency'].rank(ascending=False, method='max')
    ax = df.plot.scatter(x='word_frequency', y='rank', loglog=True,
                         figsize=[12, 6], grid=True, xlim=args.xlim)
    ax.figure.savefig(args.outfile)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('infile', type=argparse.FileType('r'), nargs='?',
                        default='-', help='Word count csv file name')
    parser.add_argument('--outfile', type=str, default='plotcounts.png',
                        help='Output image file name')
    parser.add_argument('--xlim', type=float, nargs=2, metavar=('XMIN', 'XMAX'),
                        default=None, help='X-axis limits')
    args = parser.parse_args()
    main(args)
```

In particular,
we used `plotcounts.py` to display the word counts for Dracula on a log-log plot.

```{r py-rse-git-advanced-dracula, echo=FALSE, fig.cap="Word frequency distribution for the book Dracula"}
knitr::include_graphics("figures/py-rse-git-cmdline/plot-loglog.png")
```

We noted that the relationship between word count and rank looks linear
(on a log-log scale) to the naked eye,
but to assist in that interpretation it might be helpful
to fit a curve to the data.
Fitting such a curve will require more than just a trivial change to the script,
so to keep our working version of `plotcounts.py`
separated from our attempts to fit a curve,
we can create a new development branch.
Once we've successfully added the curve fitting code to `plotcounts.py`,
we can decide if we want to merge/incorporate those changes back into the `master` branch.


## How do we create a new branch? {#py-rse-git-advanced-branch-how}

To create our new branch (which we'll call `fit`),
we run:

```shell
$ git branch fit
```

We can check that the branch exists by running `git branch` again:

```shell
$ git branch
```

```text
* master
  fit
```

Our branch is there,
but the asterisk `*` shows that we are still in the `master` branch.
(By analogy,
creating a new directory doesn't automatically move us into that directory.)
As a further check,
let's see what our repository's status is:

```shell
$ git status
```

```text
On branch master
nothing to commit, working directory clean
```

To switch to our new branch we can use the `checkout` command that we first saw
in Section \@ref(py-rse-git-cmdline-restore):

```shell
$ git checkout fit
$ git branch
```

```text
  master
* fit
```

`git checkout` doesn't just check out a file from a specific commit:
it can also check out the whole repository,
i.e.,
switch it from one saved state to another
by updating all files in the repository to match the desired state.
A branch is a human-readable name for one such state.
We can (and should) choose the name to signal the purpose of the branch,
just as we choose the names of files and variables to indicate what they are for.

At this point,
`master` and `fit` are two names for the same repository state
(Figure \@ref(fig:py-rse-git-advanced-repo-state)),
so commands like `ls` and `git log` show that the files and history haven't changed
as we switch from `master` to `fit`.
This will be true until some changes are committed to our new branch.

```{r py-rse-git-advanced-repo-state, echo=FALSE, fig.cap="Repository State"}
knitr::include_graphics("figures/FIXME.png")
```

### Fitting a curve and verifying Zipf's Law

#### The math behind Zipf's Law

Before we commit any changes to our new branch,
we need to figure out how to fit a line to the word count data.
The reason our word counts form an approximate straight line on a log-log plot
relates back to the definition of Zipf's Law,
which says,

> "The second most common word in a body of text
> appears half as often as the most common,
> the third most common appears a third as often, and so on."

In other words,
the frequency of a word (\(f\)) is proportional to its inverse rank (\(r\)), \[
f \propto \frac{1}{r^\alpha}
\]
with a value of \(\alpha\) close to one.
The reason \(\alpha\) must be close to one for Zipf's Law to hold
becomes clear if we include it in a modified version of the earlier definition:

> "The most frequent word will occur approximately \(2^\alpha\) times
> as often as the second most frequent word,
> \(3^\alpha\) times as often as the third most frequent word, and so on."

This mathematical expression for Zipf's Law is an example of a power law.
In general, when two variables \(x\) and \(y\)
are related through a power law, \[
y = ax^b
\]

taking logarithms of both sides yields a linear relationship: \[
\log(y) = \log(a) + b\log(x)
\]

Hence, plotting the variables on a log-log scale reveals this
linear relationship.  To be specific, if Zipf's Law holds,
thinking about rank as explained by frequency, we have \[
r = cf^{\frac{-1}{\alpha}}
\]
where \(c\) is a constant of proportionality.
The linear relationship between the log word frequency and
log rank is then \[
\log(r) = \log(c) - \frac{1}{\alpha}\log(f)
\]
This suggests that on our log-log plot
the points should fall on a straight line
with a slope of \(- \tfrac{1}{\alpha}\)
and intercept \(\log(c)\) (we'll see later that \(c\) is completely defined).
Our goal is to estimate the value of \(\alpha\).

#### Estimating alpha

In order to determine the best method for estimating \(\alpha\) and fitting a line to our data,
we turn to a scientific paper on Zipf’s Law in english texts [@Moreno2016].
The mathematics in the paper is a little heavy,
but the authors essentially suggest using a method called maximum likelihood estimation.
The likelihood function is the probability of our observed data,
viewed as a function of the parameters in the statistical model that we assume generated it.
In maximum likelihood estimation, we estimate the parameters in the model
by choosing them to maximize this likelihood, although
computationally, it is often easier to minimize the negative log likelihood function.
@Moreno2016 define the likelihood using a parameter, \(\beta\),
which is directly related to the \(\alpha\) parameter in our definition of Zipf's Law,
through \(\alpha = \tfrac{1}{\beta-1}\).
Under their model, the value of $c$ is the total number of unique words, or
equivalently the largest value of the rank.
Expressed as a python function,
the negative log likelihood function reads as follows:

```python
import numpy as np

def nlog_likelihood(beta, counts):
    """Log-likelihood function."""
    likelihood = - np.sum(np.log((1/counts)**(beta - 1) - (1/(counts + 1))**(beta - 1)))
    return likelihood
```

Obtaining an estimate of the \(\beta\) (and thus \(\alpha\)) parameter then becomes
a numerical optimization problem,
for which we can use the `scipy.optimize` library.
Following @Moreno2016,
we use Brent's method with \(1 < \beta \leq 4\).

```python
from scipy.optimize import minimize_scalar

def get_power_law_params(word_counts):
    """Get the power law parameters."""
    mle = minimize_scalar(nlog_likelihood, bracket=(1 + 1e-10, 4),
                          args=(word_counts), method='brent')
    beta = mle.x
    alpha = 1 / (beta - 1)
    return alpha
```

We can then plot the fitted curve on the plot axes (`ax`)
defined in the `plotcounts.py` script,

```python
def plot_fit(curve_xmin, curve_xmax, max_rank, alpha, ax):
    """
    Plot the power law curve that was fitted to the data.

    Parameters
    ----------
    curve_xmin : float
        Minimum x-bound for fitted curve
    curve_xmax : float
        Maximum x-bound for fitted curve
    max_rank : int
        Maximum word frequency rank.
    alpha : float
        Estimated alpha parameter for the power law.
    ax : matplotlib axes
        Scatter plot to which the power curve will be added.
    """
    xvals = np.arange(curve_xmin, curve_xmax)
    yvals = max_rank * (xvals**(-1 / alpha))
    ax.loglog(xvals, yvals, color='grey')
```

where the maximum word frequency rank corresponds to \(c\),
and \(-1 / \alpha\) the exponent in the power law.


#### Verifying Zipf's Law

Now that we've defined the functions required to fit a curve to our word count plots,
we can go ahead and update `plotcounts.py` accordingly:

```python
"""Plot word counts."""
import argparse
import numpy as np
import pandas as pd
from scipy.optimize import minimize_scalar


def nlog_likelihood(beta, counts):
    """Log-likelihood function."""
    likelihood = - np.sum(np.log((1/counts)**(beta - 1) - (1/(counts + 1))**(beta - 1)))
    return likelihood


def get_power_law_params(word_counts):
    """Get the power law parameters."""
    mle = minimize_scalar(nlog_likelihood, bracket=(1 + 1e-10, 4),
                          args=(word_counts), method='brent')
    beta = mle.x
    alpha = 1 / (beta - 1)
    return alpha


def set_plot_params(param_file):
    """Set the matplotlib rc parameters."""
    if param_file:
        with open(param_file, 'r') as reader:
            param_dict = yaml.load(reader, Loader=yaml.BaseLoader)
    else:
        param_dict = {}
    for param, value in param_dict.items():
        mpl.rcParams[param] = value


def plot_fit(curve_xmin, curve_xmax, max_rank, beta, ax):
    """
    Plot the power law curve that was fitted to the data.

    Parameters
    ----------
    curve_xmin : float
        Minimum x-bound for fitted curve
    curve_xmax : float
        Maximum x-bound for fitted curve
    max_rank : int
        Maximum word frequency rank.
    alpha : float
        Estimated alpha parameter for the power law.
    ax : matplotlib axes
        Scatter plot to which the power curve will be added.
    """
    xvals = np.arange(curve_xmin, curve_xmax)
    yvals = max_rank * (xvals**(-1 / alpha))
    ax.loglog(xvals, yvals, color='grey')


def main(args):
    """Run the command line program."""
    df = pd.read_csv(args.infile, header=None, names=('word', 'word_frequency'))
    df['rank'] = df['word_frequency'].rank(ascending=False, method='max')
    ax = df.plot.scatter(x='word_frequency', y='rank', loglog=True,
                         figsize=[12, 6], grid=True, xlim=args.xlim)

    alpha = get_power_law_params(df['word_frequency'].to_numpy())
    print('alpha:', alpha)
    # Since the ranks are already sorted, we can take the last one instead of
    # computing which row has the highest rank
    max_rank = df['rank'].to_numpy()[-1]
    # Use the range of the data as the boundaries when drawing the power law curve
    curve_xmin = df['word_frequency'].min()
    curve_xmax = df['word_frequency'].max()

    plot_fit(curve_xmin, curve_xmax, max_rank, alpha, ax)
    ax.figure.savefig(args.outfile)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('infile', type=argparse.FileType('r'), nargs='?',
                        default='-', help='Word count csv file name')
    parser.add_argument('--outfile', type=str, default='plotcounts.png',
                        help='Output image file name')
    parser.add_argument('--xlim', type=float, nargs=2, metavar=('XMIN', 'XMAX'),
                        default=None, help='X-axis limits')
    args = parser.parse_args()
    main(args)
```

We can then run the script to obtain the \(\alpha\) value for Dracula
and a new plot with a line fitted.

```shell
python plotcounts.py ../results/dracula.csv --outfile ../results/dracula.png
```

```text
alpha: 1.1620041050803658
```

So according to our fit,
the most frequent word will occur approximately \(2^{1.16}=2.2\) times
as often as the second most frequent word,
\(3^{1.16}=3.6\) times as often as the third most frequent word, and so on.
Here's the corresponding plot:

```shell
$ display ../results/dracula.png
```

```{r py-rse-git-advanced-dracula-fit, echo=FALSE, fig.cap="Word frequency distribution for the book Dracula"}
knitr::include_graphics("figures/rse-git-advanced/dracula_fit.png")
```

The script appears to be working as we'd like,
so we can go ahead and commit our changes to the `fit` development branch:

```shell
$ git add plotcounts.py
$ git commit -m "Added fit to word count data"
```

```text
[fit 3ff8195] Added fit to word count data
 1 file changed, 61 insertions(+)
```

If we look at the last couple of commits using `git log`,
we see our most recent change:

```shell
$ git log --oneline -n 2
```

```text
3ff8195 Added fit to word count data
d77bc5c Update dracula plot
```

(We use `--oneline` and `-n 2` to shorten the log display.)
But let's switch back to the `master` branch:

```shell
$ git checkout master
$ git branch
```

```text
* master
  fit
```

If we look at the log,
our latest change is not there:

```shell
$ git log --oneline -n 2
```

```text
d77bc5c Update dracula plot
b5176bf Edit to plot frequency against rank on log-log axes
```

We have not lost our work: it just isn't included in this branch.
We can prove this by switching back to the `fit` branch and checking the log again:

```shell
$ git checkout fit
$ git log --oneline -n 2
```

```text
3ff8195 Added fit to word count data
d77bc5c Update dracula plot
```

We can also look inside `plotcounts.py` and see our changes.
If we make another change and commit it,
that change will also go into the `fit` branch.
For instance,
we could add some additional information to one of our docstrings
to make it clear what equations were used in estimating \(\alpha\).

```python
def get_power_law_params(word_counts):
    """
    Get the power law parameters.

    References
    ----------
    Moreno-Sanchez et al (2016) define alpha (Eq. 1),
      beta (Eq. 2) and the maximum likelihood estimation (mle)
      of beta (Eq. 6).

    Moreno-Sanchez I, Font-Clos F, Corral A (2016)
      Large-Scale Analysis of Zipf’s Law in English Texts.
      PLoS ONE 11(1): e0147073.
      https://doi.org/10.1371/journal.pone.0147073
    """
    mle = minimize_scalar(nlog_likelihood, bracket=(1 + 1e-10, 4),
                          args=(word_counts), method='brent')
    beta = mle.x
    alpha = 1 / (beta - 1)
    return alpha
```

```shell
$ git add plotcounts.py
$ git commit -m "Adding Moreno-Sanchez et al (2016) reference"
```

```text
[fit db1d03f] Adding Moreno-Sanchez et al (2016) reference
 1 file changed, 14 insertions(+), 1 deletion(-)
```

And if we want to see the differences between two branches,
we can use `git diff` with the same double-dot `..` syntax we use
to view differences between two revisions:

```shell
$ git diff master..fit
```

```text
diff --git a/plotcounts.py b/plotcounts.py
index 4501eaf..d57fd63 100644
--- a/plotcounts.py
+++ b/plotcounts.py
@@ -1,6 +1,69 @@
 """Plot word counts."""
 import argparse
+import numpy as np
 import pandas as pd
+from scipy.optimize import minimize_scalar
+
+
+def nlog_likelihood(beta, counts):
+    """Log-likelihood function."""
+    likelihood = - np.sum(np.log((1/counts)**(beta - 1) - (1/(counts + 1))**(beta - 1)))
+    return likelihood
+
+
+def get_power_law_params(word_counts):
+    """
+    Get the power law parameters.
+
+    References
+    ----------
+    Moreno-Sanchez et al (2016) define alpha (Eq. 1),
+      beta (Eq. 2) and the maximum likelihood estimation (mle)
+      of beta (Eq. 6).
+
+    Moreno-Sanchez I, Font-Clos F, Corral A (2016)
+      Large-Scale Analysis of Zipf’s Law in English Texts.
+      PLoS ONE 11(1): e0147073.
+      https://doi.org/10.1371/journal.pone.0147073
+    """
+    mle = minimize_scalar(nlog_likelihood, bracket=(1 + 1e-10, 4),
+                          args=(word_counts), method='brent')
+    beta = mle.x
+    alpha = 1 / (beta - 1)
+    return alpha
+
+
+def set_plot_params(param_file):
+    """Set the matplotlib rc parameters."""
+    if param_file:
+        with open(param_file, 'r') as reader:
+            param_dict = yaml.load(reader, Loader=yaml.BaseLoader)
+    else:
+        param_dict = {}
+    for param, value in param_dict.items():
+        mpl.rcParams[param] = value
+
+
+def plot_fit(curve_xmin, curve_xmax, max_rank, alpha, ax):
+    """
+    Plot the power law curve that was fitted to the data.
+
+    Parameters
+    ----------
+    curve_xmin : float
+        Minimum x-bound for fitted curve
+    curve_xmax : float
+        Maximum x-bound for fitted curve
+    max_rank : int
+        Maximum word frequency rank.
+    alpha : float
+        Estimated alpha parameter for the power law.
+    ax : matplotlib axes
+        Scatter plot to which the power curve will be added.
+    """
+    xvals = np.arange(curve_xmin, curve_xmax)
+    yvals = max_rank * (xvals**(-1 / alpha))
+    ax.loglog(xvals, yvals, color='grey')


 def main(args):
@@ -9,6 +72,17 @@ def main(args):
     df['rank'] = df['word_frequency'].rank(ascending=False, method='max')
     ax = df.plot.scatter(x='word_frequency', y='rank', loglog=True,
                          figsize=[12, 6], grid=True, xlim=args.xlim)
+
+    alpha = get_power_law_params(df['word_frequency'].to_numpy())
+    print('alpha:', alpha)
+    # Since the ranks are already sorted, we can take the last one instead of
+    # computing which row has the highest rank
+    max_rank = df['rank'].to_numpy()[-1]
+    # Use the range of the data as the boundaries when drawing the power law curve
+    curve_xmin = df['word_frequency'].min()
+    curve_xmax = df['word_frequency'].max()
+
+    plot_fit(curve_xmin, curve_xmax, max_rank, alpha, ax)
     ax.figure.savefig(args.outfile)
```

## How do I merge work from separate branches? {#py-rse-git-advanced-merge}

Now that we're happy with the new curve fitting functionality,
we now have three options:

1.  Add our changes to `plotcounts.py` once again in the `master` branch.
2.  Stop working in `master` and start using the `fit` branch for future development.
3.  [Merge][git-merge] the `fit` and `master` branches.

The first option is tedious and error-prone,
while the second option will lead to confusion
and doesn't give us a way to combine changes made in two or more branches.
The third option the simplest, fastest, and most reliable.
To start,
let's make sure we're in the `master` branch:

```shell
$ git checkout master
$ git branch
```

```text
* master
  fit
```

We can now merge the changes in `fit` branch into our current branch
with a single command:

```shell
$ git merge fit
```

```text
Updating d77bc5c..db1d03f
Fast-forward
 plotcounts.py | 74 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 74 insertions(+)
```

Merging doesn't change the source branch `fit`.
Once the merge is done,
though,
all of the changes made in `fit` are also in the history of `master`:

```shell
$ git log --oneline -n 4
```

```text
db1d03f (HEAD -> master, fit) Adding Moreno-Sanchez et al (2016) reference
3ff8195 Added fit to word count data
d77bc5c Update dracula plot
b5176bf Edit to plot frequency against rank on log-log axes
```

Note that Git automatically creates a new commit (in this case, `db1d03f`) to represent the merge.
If we now run `git diff master..fit`,
Git doesn't print anything
because there aren't any differences to show.

Now that we have merged all of the changes from `fit` into `master`
there is no need to keep the `fit` branch,
so we can delete it:

```shell
$ git branch -d fit
```

```text
Deleted branch fit (was db1d03f).
```

> **Not Just the Command Line**
>
> We have been creating, merging, and deleting branches on the command line,
> but we can do all of these things using [GitKraken][gitkraken],
> [the RStudio IDE][rstudio-ide],
> and other GUIs.
> The operations stay the same;
> all that changes is how we tell the computer what we want to do.

## How do I handle conflicting changes? {#py-rse-git-advanced-conflict}

Merging the `fit` branch into the `master` branch went smoothly because
there were no conflicts between the two branches.
A [conflict][git-conflict] arises when two separate branches
have made edits to the same line in a file,
or when a file has been deleted in one branch but edited in the other.

To see how to handle a conflict,
let's add a README file to the `master` branch.
To start, that file will just have a header and no other content.

```shell
$ cat README.md
```

```text
# Zipf's Law
```

```shell
$ git add README.md
$ git commit -m "Initial commit of README file"
```

```text
[master b07c14a] Initial commit of README file
 1 file changed, 1 insertion(+)
 create mode 100644 README.md
```

Now let's create a new development branch called `docs`,
to work on improving the documentation for our code.

```shell
$ git checkout -b docs
```

```text
Switched to a new branch 'docs'
```

By using `checkout -b` we have created and switched to the new branch in one line.

```shell
$ git branch
```

```text
* docs
  master
```

On this new branch,
let's add some information to the README file:

```text
# Zipf's Law

These Zipf's Law scripts tally the occurrences of words in text files
and plot each word's rank versus its frequency,
together with a line for the theoretical distribution for Zipf's Law.
```

```
$ git add README.md
$ git commit -m "Added repository overview"
```

```text
[docs a41a6ea] Added repository overview
 1 file changed, 5 insertions(+), 1 deletion(-)
```

In order to create a conflict,
let's switch back to the `master` branch.

The changes we made in the `docs` branch are now gone,

```shell
$ cat README.md
```

```text
# Zipf's Law
```

so let's go ahead and add some information about the contributors to our work:

```text
# Zipf's Law

## Contributors

- Amira Khan <amira@zipfs.org>
```

```
$ git add README.md
$ git commit -m "Added contributor list"
```

```text
[master a102c83] Added contributor list
 1 file changed, 5 insertions(+), 1 deletion(-)
```

We now have two branches,
`master` and `docs`,
in which we have changed the same lines of `README.md` in different ways:

```shell
$ git diff docs..master
```

```text
diff --git a/README.md b/README.md
index fd3de28..cf317ea 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,5 @@
 # Zipf's Law

-These Zipf's Law scripts tally the occurrences of words in text files
-and plot each word's rank versus its frequency,
-together with a line for the theoretical distribution for Zipf's Law.
+## Contributors
+
+- Amira Khan <amira@zipfs.org>
```

When we try to merge `docs` into `master`,
Git doesn't know which of these changes we want to keep.

```shell
$ git merge docs master
```

```text
Auto-merging README.md
CONFLICT (content): Merge conflict in README.md
Automatic merge failed; fix conflicts and then commit the result.
```

If we look in `README.md`,
we see that Git has kept both sets of changes,
but has marked which came from where:

```shell
$ cat README.md
```

```text
# Zipf's Law

<<<<<<< HEAD
## Contributors

- Amira Khan <amira@zipfs.org>
=======
These Zipf's Law scripts tally the occurrences of words in text files
and plot each word's rank versus its frequency,
together with a line for the theoretical distribution for Zipf's Law.
>>>>>>> docs
```

The lines from `<<<<<<< HEAD` to `=======` are what was in `master`,
while the lines from there to `>>>>>>> docs` show what was in `docs`.
If there were several conflicting regions in the same file,
Git would mark each one this way.

We have to decide what to do next:
keep the `master` changes,
keep those from `docs`,
edit this part of the file to combine them,
or write something new.
Whatever we do,
we must remove the `>>>`, `===`, and `<<<` markers.
Let's combine the two sets of changes:

```shell
$ cat README.md
```

```text
# Zipf's Law

These Zipf's Law scripts tally the occurrences of words in text files
and plot each word's rank versus its frequency,
together with a line for the theoretical distribution for Zipf's Law.

## Contributors

- Amira Khan <amira@zipfs.org>
```

We can now add the file and commit the change:

```shell
$ git add README.md
$ git commit -m "Merging README additions"
```

```text
[master 4ffeaa4] Merging README additions
```

The project's history now shows a single sequence of commits,
with the `master` changes on top of the earlier `docs` changes:

```shell
$ git log --oneline
```

```text
4ffeaa4 (HEAD -> master) Merging README additions
a102c83 Added contributors list
a41a6ea (docs) Added repository overview
b07c14a Initial commit of README file
```

If we want to see what really happened,
we can add the `--graph` option to `git log`:

```shell
$ git log --oneline --graph
```

```text
*   4ffeaa4 (HEAD -> master) Merging README additions
|\  
| * a41a6ea (docs) Added repository overview
* | a102c83 Added contributors list
|/  
* b07c14a Initial commit of README file
```

Now that we're done,
we can delete the `docs` branch:

```shell
$ git branch -d docs
```

```text
Deleted branch docs (was 4ffeaa4).
```

## How should I use branches? {#py-rse-git-advanced-workflow}

Now that we're familiar with the core concepts and commands for branching,
we need to consider how best to incorporate them into our regular coding practice.
If we are working on our own computer,
this workflow will help us keep track of what we are doing:

1.  `git checkout master` to make sure we are in the `master` branch.

2.  `git checkout -b name-of-feature` to create a new branch.
    We *always* create a branch when making changes,
    since we never know what else might come up.
    The branch name should be as descriptive as a variable name or filename would be.

3.  Make our changes.
    If something occurs to us along the way—for example,
    if we are writing a new function and realize that
    the documentation for some other function should be updated—we do *not*
    do that work in this branch just because we happen to be there.
    Instead,
    we commit our changes,
    switch back to `master`,
    and create a new branch for the other work.

4.  When the new feature is complete,
    we `git merge master name-of-feature`
    to get any changes we merged into `master` after creating `name-of-feature`
    and resolve any conflicts.
    This is an important step:
    we want to do the merge and test that everything still works in our feature branch,
    not in `master`.

5.  Finally,
    we switch back to `master` and `git merge name-of-feature master`
    to merge our changes into `master`.
    We should not have any conflicts,
    and all of our tests should pass.

Most experienced developers use this [branch-per-feature][branch-per-feature] workflow,
but what exactly is a "feature"?
These rules make sense for small projects with or without collaborators:

1.  Anything cosmetic that is only one or two lines long can be done in `master` and committed right away.
    "Cosmetic" means changes to comments or documentation:
    nothing that affects how code runs, not even a simple variable renaming.

2.  A pure addition that doesn't change anything else is a feature and goes into a branch.
    For example,
    if we run a new analysis and save the results,
    that should be done on its own branch
    because it might take several tries to get the analysis to run,
    and we might interrupt ourselves to fix things that we discover aren't working.

3.  Every change to code that someone might want to undo later in one step is a feature.
    For example,
    if a new parameter is added to a function,
    then every call to the function has to be updated.
    Since neither alteration makes sense without the other,
    those changes are considered a single feature and should be done in one branch.

The hardest thing about using a branch-per-feature workflow is sticking to it for small changes.
As the first point in the list above suggests,
most people are pragmatic about this on small projects;
on large ones,
where dozens of people might be committing,
even the smallest and most innocuous change needs to be in its own branch
so that it can be reviewed (which we discuss below).

## How can I use someone else's work? {#py-rse-git-advanced-fork}

So far we have used Git to manage individual work,
but it really comes into its own when we are working with other people.
We can do this in two ways:

1.  Everyone has read and write access to a single shared repository.

2.  Everyone can read from the project's main repository,
    but only a few people can commit changes to it.
    The project's other contributors [fork][git-fork] the main repository to create one that they own,
    do their work in that,
    and then submit their changes to the main repository.

The first approach works well for teams of up to half a dozen people
who are all comfortable using Git,
but if the project is larger,
or if contributors are worried that they might make a mess in the `master` branch,
the second approach is safer.

Git itself doesn't have any notion of a "main repository",
but [forges][forge] like GitHub, GitLab, and BitBucket all encourage people
to use Git in ways that effectively create one.
Suppose,
for example,
that Sami wants to contribute to the Zipf's Law code that
Amira is hosting on GitHub at `https://github.com/amira-khan/zipf`.
Sami can go to that URL and click on the "Fork" button in the upper right corner
(Figure \@ref(fig:py-rse-git-advanced-fork-button)).
GitHub immediately creates a copy of Amira's repository within Sami's account on GitHub's own servers.
When the command completes,
the setup on GitHub now looks like this:

```{r py-rse-git-advanced-fork-button, echo=FALSE, fig.cap="Forking"}
knitr::include_graphics("figures/FIXME.png")
```

Nothing has happened yet on Sami's own machine:
the new repository exists only on GitHub.
When Sami explores its history,
they see that it contains all of the changes Amira made.

A copy of a repository is called a [clone][git-clone].
In order to start working on the project,
Sami needs to create a clone of *their* repository (not Amira's) on their own computer.
We will modify Sami's prompt to include their desktop user ID (`sami`)
and working directory (initially `~`)
to make it easier to follow what's happening:

```shell
sami:~ $ git clone https://github.com/sami/zipf.git
```

```text
Cloning into 'zipf'...
remote: Enumerating objects: 32, done.
remote: Counting objects: 100% (32/32), done.
remote: Compressing objects: 100% (16/16), done.
remote: Total 32 (delta 5), reused 32 (delta 5), pack-reused 0
Unpacking objects: 100% (32/32), done.
```

This command creates a new directory with the same name as the project,
i.e., `zipf`.
When Sami goes into this directory and runs `ls` and `git log`,
they see that all of the project's files and history are there:

```shell
sami:~ $ cd zipf
sami:~/zipf $ ls
```

```text
README.md       bin             data             results
```

```shell
jj:~/zipf $ git log --oneline -n 4
```

```text
4ffeaa4 (HEAD -> master) Merging README additions
a102c83 Added contributors list
a41a6ea (docs) Added repository overview
b07c14a Initial commit of README file```

Sami also sees that Git has automatically created a remote for their repository
that points back at their repository on GitHub:

```shell
jj:~/zipf $ git remote -v
```

```text
origin  https://github.com/sami/zipf.git (fetch)
origin  https://github.com/sami/zipf.git (push)
```

Sami can pull changes from their fork and push work back there,
but first needs to do one more thing before getting the changes from Amira's repository:

```shell
sami:~/zipf $ git remote add upstream https://github.com/amira-khan/zipf.git
sami:~/zipf $ git remote -v
```

```text
origin      https://github.com/sami/zipf.git (fetch)
origin      https://github.com/sami/zipf.git (push)
upstream    https://github.com/amira-khan/zipf.git (fetch)
upstream    https://github.com/amira-khan/zipf.git (push)
```

Sami has called their new remote `upstream` because it points at the repository theirs are derived from.
They could use any name,
but `upstream` is a nearly universal convention.

With this remote in place,
Sami is finally set up.
Suppose,
for example,
that Amira has modified the project's `README.md` file to add Sami as a contributor.
(Again, we show Amira's user ID and working directory in her prompt to make it clear who's doing what).


```shell
amira:~/zipf $ pwd
```

```text
/Users/amira/zipf
```

```shell
amira:~/zipf $ nano README.md
amira:~/zipf $ cat README.md
```

```text
# Zipf's Law analysis

Contributors:

-   Amira Khan
-   Sami Virtanen
```

Amira commits her changes and pushes them to *her* repository on GitHub:

```shell
amira:~/zipf $ git commit -m "Adding Sami as a contributor"
```

```text
[master 766c2cd] Adding Sami as a contributor
 1 file changed, 6 insertions(+)
```

```shell
amira:~/zipf $ git push origin master
```

```text
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 340.00 KiB/s, done.
Total 3 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To https://github.com/amira-khan/zipf.git
   b0c3fc6..766c2cd  master -> master
```

Amira's changes are now on her desktop and in her GitHub repository
but not in either of Sami's repositories.
Since Sami has created a remote that points at Amira's GitHub repository,
though,
they can easily pull those changes to their desktop:

```shell
sami:~/zipf $ git pull upstream master
```

```text
remote: Enumerating objects: 5, done.
remote: Counting objects: 100% (5/5), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0
Unpacking objects: 100% (3/3), done.
From https://github.com/amira-khan/zipf
 * branch            master     -> FETCH_HEAD
 * [new branch]      master     -> upstream/master
Updating b0c3fc6..766c2cd
Fast-forward
 README.md | 6 ++++++
 1 file changed, 6 insertions(+)
```

Pulling from a repository owned by someone else
is no different than pulling from a repository we own.
In either case,
Git merges the changes and asks us to resolve any conflicts that arise.
The only significant difference is that,
as with `git push` and `git pull`,
we have to specify both a remote and a branch:
in this case,
`upstream` and `master`.

## What is a pull request and how do I create one? {#py-rse-git-advanced-pull-requests}

Sami can now get Amira's work,
but how can Amira get Sami's?
One way would be for Amira to create a remote that pointed at Sami's repository on GitHub
and then pull in Sami's changes periodically,
but that would lead to chaos,
since we could never be sure that everyone's work was in any one place at the same time.
Instead,
almost everyone uses [pull requests][pull-request] instead.

Pull requests aren't part of Git itself,
but a great way to collaborate with others using [forges][forge] like GitHub.
A pull request is essentially a note saying,
"Someone would like to merge branch A of repository B into branch X of repository Y".
The pull request does not contain the changes,
but instead points at two particular branches.
If either branch changes,
the difference displayed is always up to date.

A pull request can store more than just the source and destination branches:
it can also store comments people have made about the proposed merge.
GitHub and other [forges][forge] allow users to comment on the pull request as a whole,
or on particular lines,
and mark comments as out of date
if the author of the pull request updates the code that the comment is attached to.
It is common for complex changes to go through several rounds of review and revision
before being merged.

To see this in action,
suppose that Sami wants to add their email address to `README.md` in the plotting project.
They create a new branch and switch to it,

```shell
sami:~/zipf $ git checkout -b adding-email
```

```text
Switched to a new branch 'adding-email'
```

then make a change and commit it:

```shell
sami:~/zipf $ nano README.md
sami:~/zipf $ git commit -a -m "Adding my email address"
```

```text
[master b8938eb] Adding my email address
 1 file changed, 1 insertion(+), 1 deletion(-)
```

```shell
sami:~/zipf $ git diff -r HEAD~1
```

```text
diff --git a/README.md b/README.md
index a55a9bb..eb24a3f 100644
--- a/README.md
+++ b/README.md
@@ -3,4 +3,4 @@
 Contributors:

 -   Amira Khan
--   Sami Virtanen
+-   Sami Virtanen <sami@zipfs.org>
```

Sami's changes are in their desktop repository, and *only* in their desktop repository.
They cannot create a pull request until those changes are on GitHub,
so they push their new branch to their repository on GitHub:

```shell
sami:~/zipf $ git push origin adding-email
```

```text
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 307 bytes | 307.00 KiB/s, done.
Total 3 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
remote:
remote: Create a pull request for 'adding-email' on GitHub by visiting:
remote:      https://github.com/sami/zipf/pull/new/adding-email
remote:
To https://github.com/sami/zipf.git
 * [new branch]      adding-email -> adding-email
```

When Sami goes to their GitHub repository in the browser,
GitHub notices that they have just pushed a new branch
and asks them if they want to create a pull request:

```{r image-after-jean-pushes, echo=FALSE, fig.cap="After Jean Pushes"}
knitr::include_graphics("figures/rse-git-advanced/after-jean-pushes.png")
```

When Sami clicks on the button,
GitHub displays a page showing the default source and destination of the pull request
and a pair of editable boxes for the pull request's title and a longer comment:

```{r image-pull-request-a, echo=FALSE, fig.cap="Starting Pull Request"}
knitr::include_graphics("figures/rse-git-advanced/pull-request-a.png")
```

If they scroll down,
Sami can see a summary of the changes that will be in the pull request:

```{r image-pull-request-b, echo=FALSE, fig.cap="Summary of Pull Request"}
knitr::include_graphics("figures/rse-git-advanced/pull-request-b.png")
```

They fill in the top two boxes:

```{r image-fill-in-pull-request, echo=FALSE, fig.cap="Filling In Pull Request"}
knitr::include_graphics("figures/rse-git-advanced/fill-in-pull-request.png")
```

and click on "Create Pull Request".
GitHub does that
and then displays a page showing the new pull request:

```{r image-new-pull-request, echo=FALSE, fig.cap="New Pull Request"}
knitr::include_graphics("figures/rse-git-advanced/new-pull-request.png")
```

Note that this pull request is displayed in Amira's repository rather than Sami's
since it is Amira's repository that will be affected if the pull request is merged.

Some time later,
Amira checks her repository and sees that there is a pull request:

```{r image-viewing-new-pull-request, echo=FALSE, fig.cap="Viewing Pull Request"}
knitr::include_graphics("figures/rse-git-advanced/viewing-new-pull-request.png")
```

Clicking on the "Pull requests" tab brings up a list of PRs:

```{r image-pr-list, echo=FALSE, fig.cap="Listing Pull Requests"}
knitr::include_graphics("figures/rse-git-advanced/pr-list.png")
```

and clicking on the pull link itself displays more information about it:

```{r image-pr-details, echo=FALSE, fig.cap="Pull Request Details"}
knitr::include_graphics("figures/rse-git-advanced/pr-details.png")
```

Since there are no conflicts,
GitHub will allow Amira to merge the PR immediately using the "Merge pull request" button.
She could also discard or reject it *without* merging using the "Close pull request" button.
Instead,
she clicks on the "Files changed" tab to see what Sami has changed:

```{r image-pr-changes, echo=FALSE, fig.cap="Files Changed"}
knitr::include_graphics("figures/rse-git-advanced/pr-changes.png")
```

If she moves her mouse over particular lines,
a white-on-blue cross appears near the numbers to indicate that she can add comments:

```{r image-pr-comment-marker, echo=FALSE, fig.cap="Comment Marker"}
knitr::include_graphics("figures/rse-git-advanced/pr-comment-marker.png")
```

She clicks on the marker beside her own name and writes a comment:

```{r image-pr-writing-comment, echo=FALSE, fig.cap="Writing Comment"}
knitr::include_graphics("figures/rse-git-advanced/pr-writing-comment.png")
```

She only wants to make one comment rather than write a lengthier multi-comment review,
so she clicks on "Add single comment".
GitHub redisplays the page with her comment inserted inline:

```{r image-pr-with-comment, echo=FALSE, fig.cap="Pull Request With Comment"}
knitr::include_graphics("figures/rse-git-advanced/pr-with-comment.png")
```

While all of this has been doing on,
GitHub has been emailing notifications to both Sami and Amira.
When Sami clicks on the link in theirs,
it takes them to the PR and shows Amira's comment.
Sami changes `README.md`,
commits,
and pushes,
but does *not* create a new pull request or do anything to the existing one.
As explained above,
a PR is a note asking that two branches be merged,
so if either end of the merge changes,
the PR updates automatically.

Sure enough,
when Amira looks at the PR again a few moments later she sees this:

```{r image-pr-with-fix, echo=FALSE, fig.cap="Pull Request With Fix"}
knitr::include_graphics("figures/rse-git-advanced/pr-with-fix.png")
```

Satisfied,
she goes back to the "Conversation" tab and clicks on "Merge".
The icon at the top of the PR's page changes text and color to show that the merge was successful:

```{r image-pr-successful-merge, echo=FALSE, fig.cap="Successful Merge"}
knitr::include_graphics("figures/rse-git-advanced/pr-successful-merge.png")
```

To get those changes from GitHub to her desktop repository,
Amira uses `git pull`:

```shell
amira:~/zipf $ git pull origin master
```

```text
remote: Enumerating objects: 9, done.
remote: Counting objects: 100% (9/9), done.
remote: Compressing objects: 100% (5/5), done.
remote: Total 7 (delta 3), reused 5 (delta 2), pack-reused 0
Unpacking objects: 100% (7/7), done.
From https://github.com/amira-khan/zipf
 * branch            master     -> FETCH_HEAD
   766c2cd..984b116  master     -> origin/master
Updating 766c2cd..984b116
Fast-forward
 README.md | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
```

To get the change they just made from their `adding-email` branch into their `master` branch,
Sami could use `git merge` on the command line.
It's a little clearer,
though,
if they also use `git pull` from their `upstream` repository (i.e., Amira's repository)
so that they're sure to get any other changes that Amira may have merged:

```shell
sami:~/zipf $ git checkout master
```

```text
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 1 commit.
  (use "git push" to publish your local commits)
```

```shell
sami:~/zipf $ git pull upstream master
```

```text
remote: Enumerating objects: 1, done.
remote: Counting objects: 100% (1/1), done.
remote: Total 1 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (1/1), done.
From https://github.com/amira-khan/zipf
 * branch            master     -> FETCH_HEAD
   766c2cd..984b116  master     -> upstream/master
Updating 766c2cd..984b116
Fast-forward
 README.md | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
```

All four repositories are now synchronized.

This process may seem overly complicated when it is described step by step,
but it quickly becomes second nature.
Everyone involved in the project can work at their own pace,
picking up others' changes and submitting their own whenever they want.
More importantly,
everyone has a chance to review work before it lands in the main repository.
As we discuss in Section \@ref(py-rse-style-review),
doing reviews doesn't just prevent errors from creeping in:
it is also an effective way to spread understanding and skills.

## Summary {#py-rse-git-advanced-summary}

FIXME: summarize advanced Git chapter.

## Exercises {#py-rse-git-advanced-exercises}

FIXME: create exercises for advanced Git using the Zipf's Law novels.

## Key Points {#py-rse-git-advanced-keypoints}

```{r, child="keypoints/rse-git-advanced.md"}
```

```{r, child="./links.md"}
```
