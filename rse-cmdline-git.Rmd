# Git at the command line {#cmdline-git}

## Questions {#cmdline-git-questions}

```{r, child="questions/cmdline-git.md"}
```

## Objectives {#cmdline-git-objectives}

```{r, child="objectives/cmdline-git.md"}
```

## Introduction {#cmdline-git-intro}

A version control system stores a master copy of your code in a repository,
which you can’t edit directly.
Instead, you checkout a working copy of the code,
edit that code, then commit changes back to the repository.
In this way, the system records a complete revision history (i.e. of every commit),
so that you can retrieve and compare previous versions at any time.
This is useful from an individual viewpoint,
because you don’t need to store multiple (but slightly different) copies of the same script.

TODO: Figure - [PhD Comics, A Story Told in File Names](http://phdcomics.com/comics.php?f=1323) 

It’s also useful from a collaboration viewpoint,
because the system keeps a record of who made what changes when
and prevents people from overwriting other people's work.

In a previous lesson (TODO: provide link),
we learned the basics of a version control system called Git
via a popular graphical user interface called GitKraken.
Such interfaces are a relatively new development - originally
Git could only be used at the command line.
GitKraken and other similar products simplify
the command line experience by allowing users to point and click
(which is great for teaching and learning),
but the tradeoff is that users aren't able to access the full functionality of Git.
Graphical interfaces also often cost money to use,
and aren't always installed on remote computing facilities (e.g. supercomputing or cloud facilities).
Long story short,
while products like GitKraken are a good version control solution for many people,
due to issues of functionality, cost, accessibility and/or personal preference,
others may need or want to use Git via the command line.
This chapter describes how to do just that.


## Setting up Git {#cmdline-git-setup}

When we use Git on a new computer for the first time,
we need to configure a few things. Below are a few examples
of configurations we will set as we get started with Git:

*   our name and email address,
*   what our preferred text editor is,
*   and that we want to use these settings globally (i.e. for every project).

On a command line, Git commands are written as `git verb options`,
where `verb` is what we actually want to do and `options` is additional optional information which may be needed for the `verb`. So here is how
Dracula sets up his new laptop:

```shell
$ git config --global user.name "Vlad Dracula"
$ git config --global user.email "vlad@tran.sylvan.ia"
```

Please use your own name and email address instead of Dracula's.
This user name and email will be associated with your subsequent Git activity,
which means that any changes pushed to
[GitHub](https://github.com/),
[BitBucket](https://bitbucket.org/),
[GitLab](https://gitlab.com/) or
another Git host server
in a later lesson will include this information.

For these lessons, we will be interacting with [GitHub](https://github.com/) and
so the email address used should be the same as the one used when setting up your GitHub account.
If you are concerned about privacy,
please review [GitHub's instructions for keeping your email address private][git-privacy]. 

Dracula also has to set his favorite text editor, following this table:

| Editor             | Configuration command                            |
|:-------------------|:-------------------------------------------------|
| Atom | `$ git config --global core.editor "atom --wait"`|
| nano               | `$ git config --global core.editor "nano -w"`    |
| BBEdit (Mac, with command line tools) | `$ git config --global core.editor "bbedit -w"`    |
| Sublime Text (Mac) | `$ git config --global core.editor "/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl -n -w"` |
| Sublime Text (Win, 32-bit install) | `$ git config --global core.editor "'c:/program files (x86)/sublime text 3/sublime_text.exe' -w"` |
| Sublime Text (Win, 64-bit install) | `$ git config --global core.editor "'c:/program files/sublime text 3/sublime_text.exe' -w"` |
| Notepad++ (Win, 32-bit install)    | `$ git config --global core.editor "'c:/program files (x86)/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"`|
| Notepad++ (Win, 64-bit install)    | `$ git config --global core.editor "'c:/program files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"`|
| Kate (Linux)       | `$ git config --global core.editor "kate"`       |
| Gedit (Linux)      | `$ git config --global core.editor "gedit --wait --new-window"`   |
| Scratch (Linux)       | `$ git config --global core.editor "scratch-text-editor"`  |
| Emacs              | `$ git config --global core.editor "emacs"`   |
| Vim                | `$ git config --global core.editor "vim"`   |
| VS Code                | `$ git config --global core.editor "code --wait"`   |

It is possible to reconfigure the text editor for Git whenever you want to change it.

> **Exiting Vim**
>
> Note that Vim is the default editor for many programs.
> If you haven't used Vim before and wish to exit a session
> without saving your changes, press <kbd>Esc</kbd> then type `:q!` and hit <kbd>Return</kbd>.
> If you want to save your changes and quit, press <kbd>Esc</kbd> then type `:wq` and hit <kbd>Return</kbd>.

The four commands we just ran above only need to be run once: the flag `--global` tells Git
to use the settings for every project, in your user account, on this computer.

You can check your settings at any time:

```shell
$ git config --list
```

You can change your configuration as many times as you want: use the
same commands to choose another editor or update your email address.

> **Proxy**
>
> In some networks you need to use a
> [proxy](https://en.wikipedia.org/wiki/Proxy_server). If this is the case, you
> may also need to tell Git about the proxy:
>
> ```shell
> $ git config --global http.proxy proxy-url
> $ git config --global https.proxy proxy-url
> ```
>
> To disable the proxy, use
>
> ```shell
> $ git config --global --unset http.proxy
> $ git config --global --unset https.proxy
> ```

> **Git Help and Manual**
>
> Always remember that if you forget a `git` command,
> you can access the list of commands by using `-h` and access the Git manual by using `--help` :
>
> ```shell
> $ git config -h
> $ git config --help
> ```


## Creating a repository {#cmdline-git-repos}

Once Git is configured,
we can start using it.

We will continue with the story of Wolfman and Dracula who are investigating if it
is possible to send a planetary lander to Mars. 

*TODO: Figure - Motivating Example [../fig/motivatingexample.png](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/motivatingexample.png)*

First, let's create a directory in `Desktop` folder for our work and then move into that directory:

```shell
$ cd ~/Desktop
$ mkdir planets
$ cd planets
```

Then we tell Git to make `planets` a repository — a place where Git can store versions of our files:

```shell
$ git init
```

It is important to note that `git init` will create a repository that
includes subdirectories and their files---there is no need to create
separate repositories nested within the `planets` repository,
whether subdirectories are present from the beginning or added later.
Also, note that the creation of the `planets` directory and its initialization as a
repository are completely separate processes.

If we use `ls` to show the directory's contents,
it appears that nothing has changed:

```shell
$ ls
```

But if we add the `-a` flag to show everything,
we can see that Git has created a hidden directory within `planets` called `.git`:

```shell
$ ls -a
```

```text
.	..	.git
```

Git uses this special sub-directory to store all the information about the project, 
including all files and sub-directories located within the project's directory.
If we ever delete the `.git` sub-directory,
we will lose the project's history.

We can check that everything is set up correctly
by asking Git to tell us the status of our project:

```shell
$ git status
```

```text
# On branch master
#
# Initial commit
#
nothing to commit (create/copy files and use "git add" to track)
```

If you are using a different version of `git`, the exact
wording of the output might be slightly different.


## Tracking changes {#cmdline-git-changes}

First let's make sure we're still in the right directory.
You should be in the `planets` directory.

```shell
$ cd ~/Desktop/planets
```

Let's create a file called `mars.txt` that contains some notes
about the Red Planet's suitability as a base.
We'll use `nano` to edit the file;
you can use whatever editor you like.
In particular, this does not have to be the `core.editor` you set globally earlier.

```shell
$ nano mars.txt
```

Type the text below into the `mars.txt` file:

```text
Cold and dry, but everything is my favorite color
```

Let's first verify that the file was properly created by running the list command (`ls`):

```shell
$ ls
```

```text
mars.txt
```

`mars.txt` contains a single line, which we can see by running:

```shell
$ cat mars.txt
```

```text
Cold and dry, but everything is my favorite color
```

If we check the status of our project again,
Git tells us that it's noticed the new file:

```shell
$ git status
```

```text
On branch master

Initial commit

Untracked files:
   (use "git add <file>..." to include in what will be committed)

	mars.txt
nothing added to commit but untracked files present (use "git add" to track)
```

The "untracked files" message means that there's a file in the directory
that Git isn't keeping track of.
We can tell Git to track a file using `git add`:

```shell
$ git add mars.txt
```

and then check that the right thing happened:

```shell
$ git status
```

```text
On branch master

Initial commit

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

	new file:   mars.txt

```

Git now knows that it's supposed to keep track of `mars.txt`,
but it hasn't recorded these changes as a commit yet.
To get it to do that,
we need to run one more command:

```shell
$ git commit -m "Start notes on Mars as a base"
```

```text
[master (root-commit) f22b25e] Start notes on Mars as a base
 1 file changed, 1 insertion(+)
 create mode 100644 mars.txt
```

When we run `git commit`,
Git takes everything we have told it to save by using `git add`
and stores a copy permanently inside the special `.git` directory.
This permanent copy is called a **commit**
(or **revision**) and its short identifier is `f22b25e`.
Your commit may have another identifier.

We use the `-m` flag (for "message")
to record a short, descriptive, and specific comment that will help us remember later on what we did and why.
If we just run `git commit` without the `-m` option,
Git will launch `nano` (or whatever other editor we configured as `core.editor`)
so that we can write a longer message.

Good commit messages start with a brief (<50 characters) statement about the changes made in the commit.
Generally, the message should complete the sentence "If applied, this commit will" <commit message here>.
If you want to go into more detail, add a blank line between the summary line and your additional notes.
Use this additional space to explain why you made changes and/or what their impact will be.

If we run `git status` now:

```shell
$ git status
```

```text
On branch master
nothing to commit, working directory clean
```

it tells us everything is up to date.
If we want to know what we've done recently,
we can ask Git to show us the project's history using `git log`:

```shell
$ git log
```

```text
commit f22b25e3233b4645dabd0d81e651fe074bd8e73b
Author: Vlad Dracula <vlad@tran.sylvan.ia>
Date:   Thu Aug 22 09:51:46 2013 -0400

    Start notes on Mars as a base
```

`git log` lists all commits  made to a repository in reverse chronological order.
The listing for each commit includes
the commit's full identifier
(which starts with the same characters as
the short identifier printed by the `git commit` command earlier),
the commit's author,
when it was created,
and the log message Git was given when the commit was created.

> **Where Are My Changes?**
>
> If we run `ls` at this point, we will still see just one file called `mars.txt`.
> That's because Git saves information about files' history
> in the special `.git` directory mentioned earlier
> so that our filesystem doesn't become cluttered
> (and so that we can't accidentally edit or delete an old version).

Now suppose Dracula adds more information to the file.
(Again, we'll edit with `nano` and then `cat` the file to show its contents;
you may use a different editor, and don't need to `cat`.)

```shell
$ nano mars.txt
$ cat mars.txt
```

```text
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
```

When we run `git status` now,
it tells us that a file it already knows about has been modified:

```shell
$ git status
```

```text
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   mars.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

The last line is the key phrase:
"no changes added to commit".
We have changed this file,
but we haven't told Git we will want to save those changes
(which we do with `git add`)
nor have we saved them (which we do with `git commit`).
So let's do that now. It is good practice to always review
our changes before saving them. We do this using `git diff`.
This shows us the differences between the current state
of the file and the most recently saved version:

```shell
$ git diff
```

```text
diff --git a/mars.txt b/mars.txt
index df0654a..315bf3a 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1 +1,2 @@
 Cold and dry, but everything is my favorite color
+The two moons may be a problem for Wolfman
```

The output is cryptic because
it is actually a series of commands for tools like editors and `patch`
telling them how to reconstruct one file given the other.
If we break it down into pieces:

1.  The first line tells us that Git is producing output similar to the Unix `diff` command
    comparing the old and new versions of the file.
2.  The second line tells exactly which versions of the file
    Git is comparing;
    `df0654a` and `315bf3a` are unique computer-generated labels for those versions.
3.  The third and fourth lines once again show the name of the file being changed.
4.  The remaining lines are the most interesting, they show us the actual differences
    and the lines on which they occur.
    In particular,
    the `+` marker in the first column shows where we added a line.

After reviewing our change, it's time to commit it:

```shell
$ git commit -m "Add concerns about effects of Mars' moons on Wolfman"
$ git status
```

```text
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   mars.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

Whoops:
Git won't commit because we didn't use `git add` first.
Let's fix that:

```shell
$ git add mars.txt
$ git commit -m "Add concerns about effects of Mars' moons on Wolfman"
```

```text
[master 34961b1] Add concerns about effects of Mars' moons on Wolfman
 1 file changed, 1 insertion(+)
```

Git insists that we add files to the set we want to commit
before actually committing anything. This allows us to commit our
changes in stages and capture changes in logical portions rather than
only large batches.
For example,
suppose we're adding a few citations to relevant research to our thesis.
We might want to commit those additions,
and the corresponding bibliography entries,
but *not* commit some of our work drafting the conclusion
(which we haven't finished yet).

To allow for this,
Git has a special *staging area*
where it keeps track of things that have been added to nthe current changeset
but not yet committed.

> **Staging Area**
>
> If you think of Git as taking snapshots of changes over the life of a project,
> `git add` specifies *what* will go in a snapshot
> (putting things in the staging area),
> and `git commit` then *actually takes* the snapshot, and
> makes a permanent record of it (as a commit).
> If you don't have anything staged when you type `git commit`,
> Git will prompt you to use `git commit -a` or `git commit --all`,
> which is kind of like gathering *everyone* for the picture!
> However, it's almost always better to
> explicitly add things to the staging area, because you might
> commit changes you forgot you made. (Going back to snapshots,
> you might get the extra with incomplete makeup walking on
> the stage for the snapshot because you used `-a`!)
> Try to stage things manually,
> or you might find yourself searching for "git undo commit" more
> than you would like!

*TODO: Figure - The Git Staging Area [../fig/git-staging-area.svg](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/git-staging-area.svg)*

Let's watch as our changes to a file move from our editor
to the staging area
and into long-term storage.
First,
we'll add another line to the file:

```shell
$ nano mars.txt
$ cat mars.txt
```

```text
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
```

```shell
$ git diff
```

```text
diff --git a/mars.txt b/mars.txt
index 315bf3a..b36abfd 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1,2 +1,3 @@
 Cold and dry, but everything is my favorite color
 The two moons may be a problem for Wolfman
+But the Mummy will appreciate the lack of humidity
```

So far, so good:
we've added one line to the end of the file
(shown with a `+` in the first column).
Now let's put that change in the staging area
and see what `git diff` reports:

```shell
$ git add mars.txt
$ git diff
```

There is no output:
as far as Git can tell,
there's no difference between what it's been asked to save permanently
and what's currently in the directory.
However,
if we do this:

```shell
$ git diff --staged
```

```text
diff --git a/mars.txt b/mars.txt
index 315bf3a..b36abfd 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1,2 +1,3 @@
 Cold and dry, but everything is my favorite color
 The two moons may be a problem for Wolfman
+But the Mummy will appreciate the lack of humidity
```

it shows us the difference between
the last committed change
and what's in the staging area.
Let's save our changes:

```shell
$ git commit -m "Discuss concerns about Mars' climate for Mummy"
```

```text
[master 005937f] Discuss concerns about Mars' climate for Mummy
 1 file changed, 1 insertion(+)
```

check our status:

```shell
$ git status
```

```text
On branch master
nothing to commit, working directory clean
```

and look at the history of what we've done so far:

```shell
$ git log
```


```text
commit 005937fbe2a98fb83f0ade869025dc2636b4dad5
Author: Vlad Dracula <vlad@tran.sylvan.ia>
Date:   Thu Aug 22 10:14:07 2013 -0400

    Discuss concerns about Mars' climate for Mummy

commit 34961b159c27df3b475cfe4415d94a6d1fcd064d
Author: Vlad Dracula <vlad@tran.sylvan.ia>
Date:   Thu Aug 22 10:07:21 2013 -0400

    Add concerns about effects of Mars' moons on Wolfman

commit f22b25e3233b4645dabd0d81e651fe074bd8e73b
Author: Vlad Dracula <vlad@tran.sylvan.ia>
Date:   Thu Aug 22 09:51:46 2013 -0400

    Start notes on Mars as a base
```

> **Word-based diffing**
>
> Sometimes, e.g. in the case of the text documents a line-wise
> diff is too coarse. That is where the `--color-words` option of
> `git diff` comes in very useful as it highlights the changed
> words using colors.

> **Paging the Log**
>
> When the output of `git log` is too long to fit in your screen,
> `git` uses a program to split it into pages of the size of your screen.
> When this "pager" is called, you will notice that the last line in your
> screen is a `:`, instead of your usual prompt.
>
> *   To get out of the pager, press <kbd>Q</kbd>.
> *   To move to the next page, press <kbd>Spacebar</kbd>.
> *   To search for `some_word` in all pages,
>     press <kbd>/</kbd>
>     and type `some_word`.
>     Navigate through matches pressing <kbd>N</kbd>.

> **Limit Log Size**
>
> To avoid having `git log` cover your entire terminal screen, you can limit the
> number of commits that Git lists by using `-N`, where `N` is the number of
> commits that you want to view. For example, if you only want information from
> the last commit you can use:
>
> ```shell
> $ git log -1
> ```
>
> ```text
> commit 005937fbe2a98fb83f0ade869025dc2636b4dad5
> Author: Vlad Dracula <vlad@tran.sylvan.ia>
> Date:   Thu Aug 22 10:14:07 2013 -0400
>
>    Discuss concerns about Mars' climate for Mummy
> ```
>
> You can also reduce the quantity of information using the
> `--oneline` option:
>
> ```shell
> $ git log --oneline
> ```
> 
> ```text
> * 005937f Discuss concerns about Mars' climate for Mummy
> * 34961b1 Add concerns about effects of Mars' moons on Wolfman
> * f22b25e Start notes on Mars as a base
> ```
>
> You can also combine the `--oneline` options with others. One useful
> combination is:
>
> ```shell
> $ git log --oneline --graph --all --decorate
> ```
>
> ```text
> * 005937f Discuss concerns about Mars' climate for Mummy (HEAD, master)
> * 34961b1 Add concerns about effects of Mars' moons on Wolfman
> * f22b25e Start notes on Mars as a base
> ```

> **Directories**
>
> Two important facts you should know about directories in Git.
>
> 1. Git does not track directories on their own, only files within them.
>    Try it for yourself:
>
>    ```shell
>    $ mkdir spaceships
>    $ git status
>    $ git add spaceships
>    $ git status
>    ```
>
>    Note, our newly created empty directory `spaceships` does not appear in
>    the list of untracked files even if we explicitly add it (_via_ `git add`) to our
>    repository. This is the reason why you will sometimes see `.gitkeep` files
>    in otherwise empty directories. Unlike `.gitignore`, these files are not special
>    and their sole purpose is to populate a directory so that Git adds it to
>    the repository. In fact, you can name such files anything you like.
>
> 2. If you create a directory in your Git repository and populate it with files,
>    you can add all files in the directory at once by:
>
>    ```shell
>    git add <directory-with-files>
>    ```
>
>    Try it for yourself:
>
>    ```shell
>    $ touch spaceships/apollo-11 spaceships/sputnik-1
>    $ git status
>    $ git add spaceships
>    $ git status
>    ```
>
>    Before moving on, we will commit these changes.
>
>    ```shell
>    $ git commit -m "Add some initial thoughts on spaceships"
>    ```

To recap, when we want to add changes to our repository,
we first need to add the changed files to the staging area
(`git add`) and then commit the staged changes to the
repository (`git commit`):

*TODO: Figure - The Git Commit Workflow [../fig/git-committing.svg](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/git-committing.svg)*


## Exploring history {#cmdline-git-history}

As we saw in the previous section, we can refer to commits by their identifiers.
You can refer to the most recent commit of the working directory by using the identifier `HEAD`.

We've been adding one line at a time to `mars.txt`,
so it's easy to track our progress by looking, so let's do that using our `HEAD`s.
Before we start,
let's make a change to `mars.txt`, adding yet another line.

```shell
$ nano mars.txt
$ cat mars.txt
```

```text
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
An ill-considered change
```

Now, let's see what we get.

```shell
$ git diff HEAD mars.txt
```

```text
diff --git a/mars.txt b/mars.txt
index b36abfd..0848c8d 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1,3 +1,4 @@
 Cold and dry, but everything is my favorite color
 The two moons may be a problem for Wolfman
 But the Mummy will appreciate the lack of humidity
+An ill-considered change.
```

which is the same as what you would get if you leave out `HEAD` (try it).  The
real goodness in all this is when you can refer to previous commits.  We do
that by adding `~1` 
(where "~" is "tilde", pronounced [**til**-d*uh*]) 
to refer to the commit one before `HEAD`.

```shell
$ git diff HEAD~1 mars.txt
```

If we want to see the differences between older commits we can use `git diff`
again, but with the notation `HEAD~1`, `HEAD~2`, and so on, to refer to them:

```shell
$ git diff HEAD~3 mars.txt
```

```text
diff --git a/mars.txt b/mars.txt
index df0654a..b36abfd 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1 +1,4 @@
 Cold and dry, but everything is my favorite color
+The two moons may be a problem for Wolfman
+But the Mummy will appreciate the lack of humidity
+An ill-considered change
```

We could also use `git show` which shows us what changes we made at an older commit as 
well as the commit message, rather than the _differences_ between a commit and our 
working directory that we see by using `git diff`.

```shell
$ git show HEAD~3 mars.txt
```

```text
commit f22b25e3233b4645dabd0d81e651fe074bd8e73b
Author: Vlad Dracula <vlad@tran.sylvan.ia>
Date:   Thu Aug 22 09:51:46 2013 -0400

    Start notes on Mars as a base

diff --git a/mars.txt b/mars.txt
new file mode 100644
index 0000000..df0654a
--- /dev/null
+++ b/mars.txt
@@ -0,0 +1 @@
+Cold and dry, but everything is my favorite color
```

In this way,
we can build up a chain of commits.
The most recent end of the chain is referred to as `HEAD`;
we can refer to previous commits using the `~` notation,
so `HEAD~1`
means "the previous commit",
while `HEAD~123` goes back 123 commits from where we are now.

We can also refer to commits using
those long strings of digits and letters
that `git log` displays.
These are unique IDs for the changes,
and "unique" really does mean unique:
every change to any set of files on any computer
has a unique 40-character identifier.
Our first commit was given the ID
`f22b25e3233b4645dabd0d81e651fe074bd8e73b`,
so let's try this:

```shell
$ git diff f22b25e3233b4645dabd0d81e651fe074bd8e73b mars.txt
```

```text
diff --git a/mars.txt b/mars.txt
index df0654a..93a3e13 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1 +1,4 @@
 Cold and dry, but everything is my favorite color
+The two moons may be a problem for Wolfman
+But the Mummy will appreciate the lack of humidity
+An ill-considered change
```

That's the right answer,
but typing out random 40-character strings is annoying,
so Git lets us use just the first few characters:

```shell
$ git diff f22b25e mars.txt
```

```text
diff --git a/mars.txt b/mars.txt
index df0654a..93a3e13 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1 +1,4 @@
 Cold and dry, but everything is my favorite color
+The two moons may be a problem for Wolfman
+But the Mummy will appreciate the lack of humidity
+An ill-considered change
```

All right! So
we can save changes to files and see what we've changed—now how
can we restore older versions of things?
Let's suppose we change our mind about the last update to
`mars.txt` (the "ill-considered change").

`git status` now tells us that the file has been changed,
but those changes haven't been staged:

```shell
$ git status
```

```text
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   mars.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

We can put things back the way they were
by using `git checkout`:

```shell
$ git checkout HEAD mars.txt
$ cat mars.txt
```

```text
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
```

As you might guess from its name,
`git checkout` checks out (i.e., restores) an old version of a file.
In this case,
we're telling Git that we want to recover the version of the file recorded in `HEAD`,
which is the last saved commit.
If we want to go back even further,
we can use a commit identifier instead:

```shell
$ git checkout f22b25e mars.txt
```

```shell
$ cat mars.txt
```

```text
Cold and dry, but everything is my favorite color
```

```shell
$ git status
```

```text
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   mars.txt

```

Notice that the changes are on the staged area.
Again, we can put things back the way they were
by using `git checkout`:

```shell
$ git checkout HEAD mars.txt
```

> **Don't Lose Your HEAD**
>
> Above we used
>
> ```shell
> $ git checkout f22b25e mars.txt
> ```
>
> to revert `mars.txt` to its state after the commit `f22b25e`. But be careful! 
> The command `checkout` has other important functionalities and Git will misunderstand
> your intentions if you are not accurate with the typing. For example, 
> if you forget `mars.txt` in the previous command.
>
> ```shell
> $ git checkout f22b25e
> ```
>
> ```text
> Note: checking out 'f22b25e'.
>
> You are in 'detached HEAD' state. You can look around, make experimental
> changes and commit them, and you can discard any commits you make in this
> state without impacting any branches by performing another checkout.
>
> If you want to create a new branch to retain commits you create, you may
> do so (now or later) by using -b with the checkout command again. Example:
>
>  git checkout -b <new-branch-name>
>
> HEAD is now at f22b25e Start notes on Mars as a base
> ```
>
> The "detached HEAD" is like "look, but don't touch" here,
> so you shouldn't make any changes in this state.
> After investigating your repo's past state, reattach your `HEAD` with `git checkout master`.

It's important to remember that
we must use the commit number that identifies the state of the repository
*before* the change we're trying to undo.
A common mistake is to use the number of
the commit in which we made the change we're trying to get rid of.
In the example below, we want to retrieve the state from before the most
recent commit (`HEAD~1`), which is commit `f22b25e`:

*TODO: Figure - Git Checkout [../fig/git-checkout.svg](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/git-checkout.svg)*


So, to put it all together,
here's how Git works in cartoon form:

*TODO: Figure [https://figshare.com/articles/How_Git_works_a_cartoon/1328266](https://figshare.com/articles/How_Git_works_a_cartoon/1328266)*

> **Simplifying the Common Case**
>
> If you read the output of `git status` carefully,
> you'll see that it includes this hint:
>
> ```shell
> (use "git checkout -- <file>..." to discard changes in working directory)
> ```
>
> As it says,
> `git checkout` without a version identifier restores files to the state saved in `HEAD`.
> The double dash `--` is needed to separate the names of the files being recovered
> from the command itself:
> without it,
> Git would try to use the name of the file as the commit identifier.

The fact that files can be reverted one by one
tends to change the way people organize their work.
If everything is in one large document,
it's hard (but not impossible) to undo changes to the introduction
without also undoing changes made later to the conclusion.
If the introduction and conclusion are stored in separate files,
on the other hand,
moving backward and forward in time becomes much easier.


## Branches {#cmdline-git-branches}

*FIXME: This lesson is from [UW-Madison](https://uw-madison-datascience.github.io/git-novice-custom/07-branches/)
and therefore doesn't quite match the storyline of the other lessons.*

So far we've always been working in a straight timeline.
However, there are times when we might want to keep
our main work safe from experimental changes we are working on.
To do this we can use branches to work on separate tasks in parallel
without changing our current branch, `master`.

We didn't see it before but the first branch made is called `master`.
This is the default branch created when initializing a repository and
is often considered to be the "clean" or "working" version of a
repository's code.

We can see what branches exist in a repository by typing

```shell
$ git branch
```

```text
* master
```

The '*' indicates which branch we are currently on.

In this lesson, Dracula is trying to run an analysis
and doesn't know if it will be faster in bash or python.
To keep his master branch safe he will use separate branches
for both bash and python analysis.
Then he will merge the branch with the faster script
into his master branch.

First let's make the python branch.
We use the same `git branch` command but now add the 
name we want to give our new branch

```shell
$ git branch pythondev
```

We can now check our work with the `git branch` command.

```shell
$ git branch
```

```text
* master
  pythondev
```

We can see that we created the `pythondev` branch but we
are still in the master branch.

We can also see this in the output of the `git status` command.

```shell
$ git status
```

```text
On branch master
nothing to commit, working directory clean
```

To switch to our new branch we can use the `checkout` command
we learned earlier and check our work with `git branch`.

```shell
$ git checkout pythondev
$ git branch
```

```text
  master
* pythondev
```

Before we used the `checkout` command to checkout a file from a specific commit
using commit hashes or `HEAD` and the filename (`git checkout HEAD <file>`). The
`checkout` command can also be used to checkout an entire previous version of the
repository, updating all files in the repository to match the state of a desired commit.

Branches allow us to do this using a human-readable name rather than memorizing
a commit hash. This name also typically gives purpose to the set of changes in
that branch. When we use the command `git checkout <branch_name>`, we are using
a nickname to checkout a version of the repository that matches the most recent
commit in that branch (a.k.a. the HEAD of that branch).

Here you can use `git log` and `ls` to see that the history and 
files are the same as our `master` branch. This will be true until
some changes are committed to our new branch.

Now lets make our python script.  
For simplicity sake, we will `touch` the script making an empty file
but imagine we spent hours working on this python script for our analysis.

```shell
$ touch analysis.py
```

Now we can add and commit the script to our branch.

```shell
$ git add analysis.py
$ git commit -m "Wrote and tested python analysis script"
```

```text
[pythondev x792csa1] Wrote and tested python analysis script
 1 file changed, 1 insertion(+)
 create mode 100644 analysis.py
```

Lets check our work!

```shell
$ ls
$ git log --oneline
```

As expected, we see our commit in the log.

Now let's switch back to the `master` branch.

```shell
$ git checkout master
$ git branch
```

```text
* master
  pythondev
```

Let's explore the repository a bit.

Now that we've confirmed we are on the `master` branch again.
Let's confirm that `analysis.py` and our last commit aren't in `master`.

```shell
$ ls
$ git log --oneline
```

We no longer see the file `analysis.py` and our latest commit doesn't
appear in this branch's history. But do not fear! All of our hard work
remains in the `pythondev` branch. We can confirm this by moving back
to that branch.

```shell
$ git checkout pythondev
$ git branch
```

```text
  master
* pythondev
```

```shell
$ ls
$ git log --oneline
```

And we see that our `analysis.py` file and respective commit have been
preserved in the `pythondev` branch.

Now we can repeat the process for our bash script in a branch called
`bashdev`.

First we must checkout the `master` branch again. New branches will
include the entire history up to the current commit, and we'd like
to keep these two tasks separate.

```shell
$ git checkout master
$ git branch
```

```text
* master
  pythondev
```

This time let's create and switch two the `bashdev` branch
in one command.

We can do so by adding the `-b` flag to checkout.

```shell
$ git checkout -b bashdev
$ git branch
```

```text
* bashdev
  master
  pythonndev
```

We can use `ls` and `git log` to see that this branch is 
the same as our current `master` branch.

Now we can make `analysis.sh` and add and commit it.
Again imagine instead of `touch`ing the file we worked 
on it for many hours.

```shell
$ touch analysis.sh
$ git add analysis.sh
$ git commit –m “Wrote and tested bash analysis script”
```

```text
[bashdev 2n779ds] Wrote and tested bash analysis script
 1 file changed, 1 insertion(+)
 create mode 100644 analysis.sh
```

Lets check our work again before we switch back to the master branch.

```shell
$ ls
$ git log --oneline
```

So it turns out the python `analysis.py` is much faster than `analysis.sh`.

Let's merge this version into our `master` branch so we can use it for
our work going forward.

Merging brings the changes from a different branch into 
the current branch.

First we must switch to the branch we're merging changes into, `master`.

```shell
$ git checkout master
$ git branch
```

```text
  bashdev
* master
  pythonndev
```

Now we can `merge` the `pythondev` branch into our current branch
(`master`). In english, this command could be stated as "`git`, please
`merge` the changes in the `pythondev` branch into the current branch
I'm in".

```shell
$ git merge pythondev
```

```text
Updating 12687f6..x792csa1
Fast-forward
 analysis.py | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 analysis.py
```

Now that we've merged the `pythondev` into `master`, these changes
exist in both branches. This could be confusing in the future if we
stumble upon the `pythondev` branch again.

We can delete our old branches so as to avoid this confusion later.
We can do so by adding the `-d` flag to the `git branch` command.

```shell
git branch -d pythondev
```

```text
Deleted branch pythondev (was x792csa1).
```

And because we don't want to keep the changes in the `bashdev` branch,
we can delete the `bashdev` branch as well

```shell
$ git branch -d bashdev
```

```text
error: The branch 'bashdev' is not fully merged.
If you are sure you want to delete it, run 'git branch -D bashdev'.
```

Since we've never merged the changes from the `bashdev` branch,
git warns us about deleting them and tells us to use the `-D` flag instead.

Since we really want to delete this branch we will go ahead and do so.

```shell
git branch -D bashdev
```

```text
Deleted branch bashdev (was 2n779ds).
```


## Ignoring things {#cmdline-git-ignore}

What if we have files that we do not want Git to track for us,
like backup files created by our editor
or intermediate files created during data analysis?
Let's create a few dummy files:

```shell
$ mkdir results
$ touch a.dat b.dat c.dat results/a.out results/b.out
```

and see what Git says:

```shell
$ git status
```

```text
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)

	a.dat
	b.dat
	c.dat
	results/

nothing added to commit but untracked files present (use "git add" to track)
```

Putting these files under version control would be a waste of disk space.
What's worse,
having them all listed could distract us from changes that actually matter,
so let's tell Git to ignore them.

We do this by creating a file in the root directory of our project called `.gitignore`:

```shell
$ nano .gitignore
$ cat .gitignore
```

```text
*.dat
results/
```

These patterns tell Git to ignore any file whose name ends in `.dat`
and everything in the `results` directory.
(If any of these files were already being tracked,
Git would continue to track them.)

Once we have created this file,
the output of `git status` is much cleaner:

```shell
$ git status
```

```text
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)

	.gitignore

nothing added to commit but untracked files present (use "git add" to track)
```

The only thing Git notices now is the newly-created `.gitignore` file.
You might think we wouldn't want to track it,
but everyone we're sharing our repository with will probably want to ignore
the same things that we're ignoring.
Let's add and commit `.gitignore`:

```shell
$ git add .gitignore
$ git commit -m "Ignore data files and the results folder."
$ git status
```

```text
# On branch master
nothing to commit, working directory clean
```

As a bonus, using `.gitignore` helps us avoid accidentally adding to the repository files that we don't want to track:

```shell
$ git add a.dat
```

```text
The following paths are ignored by one of your .gitignore files:
a.dat
Use -f if you really want to add them.
```

If we really want to override our ignore settings,
we can use `git add -f` to force Git to add something. For example,
`git add -f a.dat`.
We can also always see the status of ignored files if we want:

```shell
$ git status --ignored
```

```text
On branch master
Ignored files:
 (use "git add -f <file>..." to include in what will be committed)

        a.dat
        b.dat
        c.dat
        results/

nothing to commit, working directory clean
```


## Remotes in GitHub {#cmdline-git-remotes}

Version control really comes into its own when we begin to collaborate with
other people.  We already have most of the machinery we need to do this; the
only thing missing is to copy changes from one repository to another.

Systems like Git allow us to move work between any two repositories.  In
practice, though, it's easiest to use one copy as a central hub, and to keep it
on the web rather than on someone's laptop.  Most programmers use hosting
services like [GitHub](https://github.com), [Bitbucket](https://bitbucket.org) or
[GitLab](https://gitlab.com/) to hold those master copies; we'll explore the pros
and cons of this in the final section of this lesson.

Let's start by sharing the changes we've made to our current project with the
world.  Log in to GitHub, then click on the icon in the top right corner to
create a new repository called `planets`:

*TODO: Figure - Creating a Repository on GitHub (Step 1) [../fig/github-create-repo-01.png](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/github-create-repo-01.png)*

Name your repository "planets" and then click "Create Repository".

Note: Since this repository will be connected to a local repository, it needs to be empty. Leave 
"Initialize this repository with a README" unchecked, and keep "None" as options for both "Add 
.gitignore" and "Add a license." See the "GitHub License and README files" exercise below for a full 
explanation of why the repository needs to be empty.

*TODO: Figure - Creating a Repository on GitHub (Step 2) [../fig/github-create-repo-02.png](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/github-create-repo-02.png)*

As soon as the repository is created, GitHub displays a page with a URL and some
information on how to configure your local repository:

*TODO: Figure - Creating a Repository on GitHub (Step 3) [../fig/github-create-repo-03.png](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/github-create-repo-03.png)*

This effectively does the following on GitHub's servers:

```shell
$ mkdir planets
$ cd planets
$ git init
```

If you remember back to the earlier lesson where we added and committed our earlier work on `mars.txt`,
we had a diagram of the local repository which looked like this:

*TODO: Figure - The Local Repository with Git Staging Area [../fig/git-staging-area.svg](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/git-staging-area.svg)*

Now that we have two repositories, we need a diagram like this:

*TODO: Figure - Freshly-Made GitHub Repository [../fig/git-freshly-made-github-repo.svg](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/git-freshly-made-github-repo.svg)*

Note that our local repository still contains our earlier work on `mars.txt`, but the
remote repository on GitHub appears empty as it doesn't contain any files yet.

The next step is to connect the two repositories.  We do this by making the
GitHub repository a remote for the local repository.
The home page of the repository on GitHub includes the string we need to
identify it:

*TODO: Figure - Where to Find Repository URL on GitHub [../fig/github-find-repo-string.png](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/github-find-repo-string.png)*

Click on the 'HTTPS' link to change the protocol from SSH to HTTPS.

> **HTTPS vs. SSH**
>
> We use HTTPS here because it does not require additional configuration.  After
> the workshop you may want to set up SSH access, which is a bit more secure, by
> following one of the great tutorials from
> [GitHub](https://help.github.com/articles/generating-ssh-keys),
> [Atlassian/Bitbucket](https://confluence.atlassian.com/bitbucket/set-up-ssh-for-git-728138079.html)
> and [GitLab](https://about.gitlab.com/2014/03/04/add-ssh-key-screencast/)
> (this one has a screencast).

*TODO: Figure - Changing the Repository URL on GitHub [../fig/github-change-repo-string.png](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/github-change-repo-string.png)*

Copy that URL from the browser, go into the local `planets` repository, and run
this command:

```shell
$ git remote add origin https://github.com/vlad/planets.git
```

Make sure to use the URL for your repository rather than Vlad's: the only
difference should be your username instead of `vlad`.

`origin` is a local name used to refer to the remote repository. It could be called
anything, but `origin` is a convention that is often used by default in git
and GitHub, so it's helpful to stick with this unless there's a reason not to.

We can check that the command has worked by running `git remote -v`:

```shell
$ git remote -v
```

```text
origin   https://github.com/vlad/planets.git (push)
origin   https://github.com/vlad/planets.git (fetch)
```

We'll discuss remotes in more detail in the next episode, while
talking about how they might be used for collaboration.

Once the remote is set up, this command will push the changes from
our local repository to the repository on GitHub:

```shell
$ git push origin master
```

```text
Enumerating objects: 16, done.
Counting objects: 100% (16/16), done.
Delta compression using up to 8 threads.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (16/16), 1.45 KiB | 372.00 KiB/s, done.
Total 16 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), done.
To https://github.com/vlad/planets.git
 * [new branch]      master -> master
```

> **Proxy**
>
> If the network you are connected to uses a proxy, there is a chance that your
> last command failed with "Could not resolve hostname" as the error message. To
> solve this issue, you need to tell Git about the proxy:
>
> ```shell
> $ git config --global http.proxy http://user:password@proxy.url
> $ git config --global https.proxy http://user:password@proxy.url
> ```
>
> When you connect to another network that doesn't use a proxy, you will need to
> tell Git to disable the proxy using:
>
> ```shell
> $ git config --global --unset http.proxy
> $ git config --global --unset https.proxy
> ```

> **Password Managers**
>
> If your operating system has a password manager configured, `git push` will
> try to use it when it needs your username and password.  For example, this
> is the default behavior for Git Bash on Windows. If you want to type your
> username and password at the terminal instead of using a password manager,
> type:
>
> ```shell
> $ unset SSH_ASKPASS
> ```
>
> in the terminal, before you run `git push`.  Despite the name, [Git uses
> `SSH_ASKPASS` for all credential
> entry](https://git-scm.com/docs/gitcredentials#_requesting_credentials), so
> you may want to unset `SSH_ASKPASS` whether you are using Git via SSH or
> https.
>
> You may also want to add `unset SSH_ASKPASS` at the end of your `~/.bashrc`
> to make Git default to using the terminal for usernames and passwords.

Our local and remote repositories are now in this state:

*TODO: Figure - GitHub Repository After First Push [../fig/github-repo-after-first-push.svg](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/github-repo-after-first-push.svg)*


> **The '-u' Flag**
>
> You may see a `-u` option used with `git push` in some documentation.  This
> option is synonymous with the `--set-upstream-to` option for the `git branch`
> command, and is used to associate the current branch with a remote branch so
> that the `git pull` command can be used without any arguments. To do this,
> simply use `git push -u origin master` once the remote has been set up.

We can pull changes from the remote repository to the local one as well:

```shell
$ git pull origin master
```

```text
From https://github.com/vlad/planets
 * branch            master     -> FETCH_HEAD
Already up-to-date.
```

Pulling has no effect in this case because the two repositories are already
synchronized.  If someone else had pushed some changes to the repository on
GitHub, though, this command would download them to our local repository.

> **Uploading files directly in GitHub browser**
>
> Github also allows you to skip the command line and upload files directly to 
> your repository without having to leave the broswer. There are two options. 
> First you can click the "Upload files" button in the toolbar at the top of the
> file tree. Or, you can drag and drop files from your desktop onto the file 
> tree. You can read more about this [on this GitHub page](https://help.github.com/articles/adding-a-file-to-a-repository/)



## Collaborating {#cmdline-git-collaborating}

For the next step, get into pairs.  One person will be the "Owner" and the other
will be the "Collaborator". The goal is that the Collaborator add changes into
the Owner's repository. We will switch roles at the end, so both persons will
play Owner and Collaborator.

> **Practicing By Yourself**
>
> If you're working through this lesson on your own,
> you can carry on by opening a second terminal window.
> This window will represent your partner, working on another computer.
> You won't need to give anyone access on GitHub, because both 'partners' are you.

The Owner needs to give the Collaborator access.
On GitHub, click the settings button on the right,
then select Collaborators, and enter your partner's username.

*TODO: Figure - Adding Collaborators on GitHub [../fig/github-add-collaborators.png](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/github-add-collaborators.png)*

To accept access to the Owner's repo, the Collaborator
needs to go to [https://github.com/notifications](https://github.com/notifications).
Once there she can accept access to the Owner's repo.

Next, the Collaborator needs to download a copy of the Owner's repository to her
machine. This is called "cloning a repo". To clone the Owner's repo into
her `Desktop` folder, the Collaborator enters:

```shell
$ git clone https://github.com/vlad/planets.git ~/Desktop/vlad-planets
```

Replace 'vlad' with the Owner's username.

*TODO: Figure - After Creating Clone of Repository [../fig/github-collaboration.svg](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/github-collaboration.svg)*

The Collaborator can now make a change in her clone of the Owner's repository,
exactly the same way as we've been doing before:

```shell
$ cd ~/Desktop/vlad-planets
$ nano pluto.txt
$ cat pluto.txt
```

```text
It is so a planet!
```

```shell
$ git add pluto.txt
$ git commit -m "Add notes about Pluto"
```

```text
 1 file changed, 1 insertion(+)
 create mode 100644 pluto.txt
```

Then push the change to the *Owner's repository* on GitHub:

```shell
$ git push origin master
```

```text
Enumerating objects: 4, done.
Counting objects: 4, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 306 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/vlad/planets.git
   9272da5..29aba7c  master -> master
```

Note that we didn't have to create a remote called `origin`: Git uses this
name by default when we clone a repository.  (This is why `origin` was a
sensible choice earlier when we were setting up remotes by hand.)

> **Some more about remotes**
>
> In this episode and the previous one, our local repository has had
> a single "remote", called `origin`. A remote is a copy of the repository
> that is hosted somewhere else, that we can push to and pull from, and 
> there's no reason that you have to work with only one. For example, 
> on some large projects you might have your own copy in your own GitHub
> account (you'd probably call this `origin`) and also the main "upstream"
> project repository (let's call this `upstream` for the sake of examples).
> You would pull from `upstream` from time to 
> time to get the latest updates that other people have committed.
>
> Remember that the name you give to a remote only exists locally. It's
> an alias that you choose - whether `origin`, or `upstream`, or `fred` -
> and not something intrinstic to the remote repository.
>
> The `git remote` family of commands is used to set up and alter the remotes
> associated with a repository. Here are some of the most useful ones:
>
> * `git remote -v` lists all the remotes that are configured (we already used
> this in the last episode). 
> * `git remote add [name] [url]` is used to add a new remote. 
> * `git remote remove [name]` removes a remote. Note that it doesn't affect the 
> remote repository at all - it just removes the link to it from the local repo.  
> * `git remote set-url [name] [newurl]` changes the URL that is associated 
> with the remote. This is useful if it has moved, e.g. to a different GitHub
> account, or from GitHub to a different hosting service. Or, if we made a typo when
> adding it!
> * `git remote rename [oldname] [newname]` changes the local alias by which a remote 
> is known - its name. For example, one could use this to change `upstream` to `fred`.

Take a look to the Owner's repository on its GitHub website now (maybe you need
to refresh your browser.) You should be able to see the new commit made by the
Collaborator.

To download the Collaborator's changes from GitHub, the Owner now enters:

```shell
$ git pull origin master
```

```text
remote: Enumerating objects: 4, done.
remote: Counting objects: 100% (4/4), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
From https://github.com/vlad/planets
 * branch            master     -> FETCH_HEAD
   9272da5..29aba7c  master     -> origin/master
Updating 9272da5..29aba7c
Fast-forward
 pluto.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 pluto.txt
```

Now the three repositories (Owner's local, Collaborator's local, and Owner's on
GitHub) are back in sync.

> **A Basic Collaborative Workflow**
>
> In practice, it is good to be sure that you have an updated version of the
> repository you are collaborating on, so you should `git pull` before making
> our changes. The basic collaborative workflow would be:
>
> * update your local repo with `git pull origin master`,  
> * make your changes and stage them with `git add`,  
> * commit your changes with `git commit -m`, and  
> * upload the changes to GitHub with `git push origin master`
>
> It is better to make many commits with smaller changes rather than
> of one commit with massive changes: small commits are easier to
> read and review.



## Conflicts {#cmdline-git-conflicts}

As soon as people can work in parallel, they'll likely step on each other's toes.
This will even happen with a single person:
if we are working on a piece of software on both our laptop and a server in the lab,
we could make different changes to each copy.
Version control helps us manage these conflicts by giving us tools to
resolve overlapping changes.

To see how we can resolve conflicts, we must first create one.
The file `mars.txt` currently looks like this
in both partners' copies of our `planets` repository:

```shell
$ cat mars.txt
```

```text
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
```

Let's add a line to one partner's copy only:

```shell
$ nano mars.txt
$ cat mars.txt
```

```text
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
This line added to Wolfman's copy
```

and then push the change to GitHub:

```shell
$ git add mars.txt
$ git commit -m "Add a line in our home copy"
```

```text
[master 5ae9631] Add a line in our home copy
 1 file changed, 1 insertion(+)
```

```shell
$ git push origin master
```

```text
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 8 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 331 bytes | 331.00 KiB/s, done.
Total 3 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
To https://github.com/vlad/planets.git
   29aba7c..dabb4c8  master -> master
```

Now let's have the other partner
make a different change to their copy
*without* updating from GitHub:

```shell
$ nano mars.txt
$ cat mars.txt
```

```text
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
We added a different line in the other copy
```

We can commit the change locally:

```shell
$ git add mars.txt
$ git commit -m "Add a line in my copy"
```

```text
[master 07ebc69] Add a line in my copy
 1 file changed, 1 insertion(+)
```

but Git won't let us push it to GitHub:

```shell
$ git push origin master
```

```text
To https://github.com/vlad/planets.git
 ! [rejected]        master -> master (fetch first)
error: failed to push some refs to 'https://github.com/vlad/planets.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
```

*TODO: Figure - The Conflicting Changes [../fig/conflict.svg](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/conflict.svg)*

Git rejects the push because it detects that the remote repository has new updates that have not been
incorporated into the local branch.
What we have to do is pull the changes from GitHub,
merge them into the copy we're currently working in, and then push that.
Let's start by pulling:

```shell
$ git pull origin master
```

```text
remote: Enumerating objects: 5, done.
remote: Counting objects: 100% (5/5), done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 3 (delta 2), reused 3 (delta 2), pack-reused 0
Unpacking objects: 100% (3/3), done.
From https://github.com/vlad/planets
 * branch            master     -> FETCH_HEAD
    29aba7c..dabb4c8  master     -> origin/master
Auto-merging mars.txt
CONFLICT (content): Merge conflict in mars.txt
Automatic merge failed; fix conflicts and then commit the result.
```

The `git pull` command updates the local repository to include those
changes already included in the remote repository.
After the changes from remote branch have been fetched, Git detects that changes made to the local copy 
overlap with those made to the remote repository, and therefore refuses to merge the two versions to
stop us from trampling on our previous work. The conflict is marked in
in the affected file:

```shell
$ cat mars.txt
```

```text
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
<<<<<<< HEAD
We added a different line in the other copy
=======
This line added to Wolfman's copy
>>>>>>> dabb4c8c450e8475aee9b14b4383acc99f42af1d
```

Our change is preceded by `<<<<<<< HEAD`.
Git has then inserted `=======` as a separator between the conflicting changes
and marked the end of the content downloaded from GitHub with `>>>>>>>`.
(The string of letters and digits after that marker
identifies the commit we've just downloaded.)

It is now up to us to edit this file to remove these markers
and reconcile the changes.
We can do anything we want: keep the change made in the local repository, keep
the change made in the remote repository, write something new to replace both,
or get rid of the change entirely.
Let's replace both so that the file looks like this:

```shell
$ cat mars.txt
```

```text
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
We removed the conflict on this line
```

To finish merging,
we add `mars.txt` to the changes being made by the merge
and then commit:

```shell
$ git add mars.txt
$ git status
```

```text
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

	modified:   mars.txt

```

```shell
$ git commit -m "Merge changes from GitHub"
```

```text
[master 2abf2b1] Merge changes from GitHub
```

Now we can push our changes to GitHub:

```shell
$ git push origin master
```

```text
Enumerating objects: 10, done.
Counting objects: 100% (10/10), done.
Delta compression using up to 8 threads
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 645 bytes | 645.00 KiB/s, done.
Total 6 (delta 4), reused 0 (delta 0)
remote: Resolving deltas: 100% (4/4), completed with 2 local objects.
To https://github.com/vlad/planets.git
   dabb4c8..2abf2b1  master -> master
```

Git keeps track of what we've merged with what,
so we don't have to fix things by hand again
when the collaborator who made the first change pulls again:

```shell
$ git pull origin master
```

```text
remote: Enumerating objects: 10, done.
remote: Counting objects: 100% (10/10), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 6 (delta 4), reused 6 (delta 4), pack-reused 0
Unpacking objects: 100% (6/6), done.
From https://github.com/vlad/planets
 * branch            master     -> FETCH_HEAD
    dabb4c8..2abf2b1  master     -> origin/master
Updating dabb4c8..2abf2b1
Fast-forward
 mars.txt | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
```

We get the merged file:

```shell
$ cat mars.txt
```

```text
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
We removed the conflict on this line
```

We don't need to merge again because Git knows someone has already done that.

Git's ability to resolve conflicts is very useful, but conflict resolution
costs time and effort, and can introduce errors if conflicts are not resolved
correctly. If you find yourself resolving a lot of conflicts in a project,
consider these technical approaches to reducing them:

* Pull from upstream more frequently, especially before starting new work  
* Use topic branches to segregate work, merging to master when complete  
* Make smaller more atomic commits  
* Where logically appropriate, break large files into smaller ones so that it is
  less likely that two authors will alter the same file simultaneously

Conflicts can also be minimized with project management strategies:

* Clarify who is responsible for what areas with your collaborators  
* Discuss what order tasks should be carried out in with your collaborators so
  that tasks expected to change the same lines won't be worked on simultaneously  
* If the conflicts are stylistic churn (e.g. tabs vs. spaces), establish a
  project convention that is governing and use code style tools (e.g.
  `htmltidy`, `perltidy`, `rubocop`, etc.) to enforce, if necessary


## Pull requests  {#cmdline-git-pull-requests}

*FIXME: This lesson is from [UW-Madison](https://uw-madison-datascience.github.io/git-novice-custom/10-pull-requests/)
and therefore doesn't quite match the storyline of the other lessons.*

Pull requests are a great way to collaborate with others using github.
Instead of making changes directly to a repository you can suggest changes to a repo.
This can be useful if you don't have permission to modify a repository directly or
you want someone else to review your changes.

For this lesson we will be working on the `countries` repository together.
Open the github link for the `countries` repo provided by the instructor 
in your browser window.

*TODO: Figure - Upstream repo [../fig/github_screenshot_upstream_repo.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_upstream_repo.png)*

> **Repo owner differences**
>
> You may have noticed that the `countries` repo in this lesson's pictures 
> is owned by the 'McMahonLab' organization and this doesn't match
> the address you were given.
> This is to be expected because this will differ depending on 
> what organization your instructor used to setup the `countries` repo.
> 
> You will also see your username where the 'sstevens2' is in the pictures.
> 

Once at the `countries` repo, click the **Fork** button which can be found
in the upper right hand conner of the window. 
Forking the repository makes us each our own copy of the repo in our github 
account which we can edit.

*TODO: Figure - Upstream Forking [../fig/github_screenshot_upstream_forking.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_upstream_forking.png)*

Next we need to get this repo on our local computer and
setup connections from our computer to both our forked version 
and the authoritative version we forked it from.

First we will **clone** the repo from our forked version.
The clone command does two things:

1. Copies the repo to your local computer
2. Sets up a remote called 'origin' between your computer and the github repo

Copy the web address for your forked version of repo 
(from the web address line or click 'Clone and download' and copy that).

*TODO: Figure - Clone Origin [../fig/github_screenshot_cloneOrigin.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_cloneOrigin.png)*

In terminal or Gitbash, navigate to a folder you'd like to hold this repo,
we will place it on our `Desktop`.
Once there you can use the `clone` command with the link you copied as the first argument.

```shell
$ cd ~/Desktop
$ git clone https://github.com/USERNAME/countries.git
```

> **Why does the command above say 'USERNAME'?**
>
> So that we can't copy the command above and accidentally clone someone else's
> version of countries to our computer, the command above uses the placeholder
> 'USERNAME' where you should put your own username if your copied from above
> instead of copying the link from your browser and pasting it into the command.

```text
Cloning into 'countries'...
remote: Counting objects: 6, done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0
Unpacking objects: 100% (6/6), done.
```

Next we will set up a connection or **remote** to the authoritative repository 
(the original version given to you by your instructor).
In your browser, you can go back this repo by clicking on the link that says 'forked from'
in the upper left hand corner, under your username and repo name.

Copy the web address for this repo 
(from the web address line or click the 'clone and download' and copy that).

*TODO: Figure - Upstream Repo [../fig/github_screenshot_upstream_repo.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_upstream_repo.png)*

Then back in your terminal, navigate into the cloned repo and add the remote 
connection to this repository.
For this command we must give the remote a different nickname, 
where our original remote is 'origin'
this new remote will be called 'upstream'.
You could give it a different nickname but 'upstream' is a common nickname for
the authoritative repository.

```shell
$ cd countries
$ git remote add upstream https://github.com/INSTRUCTOR-GIVEN/countries.git
```

> **If you tried copying the command above...**
>
> You will have to replace 'INSTRUCTOR-GIVEN' with the site your instructor
> indicated at the beginning of this lesson. This will vary depending
> on how your instructor set up for this lesson.

At anytime you can see the remote connections your repo has using the following command:

```shell
$ git remote -v
```

```text
origin	https://github.com/USERNAME/countries.git (fetch)
origin	https://github.com/USERNAME/countries.git (push)
upstream	https://github.com/INSTRUCTOR-GIVEN/countries.git (fetch)
upstream	https://github.com/INSTRUCTOR-GIVEN/countries.git (push)
```

Now that we have this setup done we will be able to suggest 
changes to this repo using a pull request.
Each person will add a new file with info about a new country in it.

The instructor will now add a single file to the repository containing 
information about the the United States.

Next, we will update our local version of the repo to include the new file.
We use a command called `pull` to bring these changes to our local repository.
We must specify the remote and branch we want to pull from, in this case the 
`upstream` remote's `master` branch.

```shell
$ git pull upstream master
```

Now your local version of the repo is updated but our forked version of the 
repo is not yet up to date.
You can reload your fork in github and see it does not contain the new 
`united_states.txt` file.
Now we need to update our forked version.
To do so we can `push` the changes in our local version to the master branch of our fork, 
called 'origin'.

```shell
$ git push origin master
```

Now let's each add a new country to the repository.
First let's make a new branch to work on.  This will keep our 'master' version
in sync with the authoritative version of the repository.
We can name our branch descriptively after the country we will be adding.
Mine will be `addFrance` since I'll be working with France.
Please pick a different country and shout it out (or add it to the etherpad) 
so no one else chooses the same one.
We will create the branch and switch into in one step 
as we learned earlier in the branching lesson.

```shell
$ git checkout -b addFrance
```

```text
Switched to a new branch 'addFrance'
```

Finally before we proceed to adding the new file, we will double 
check that we are on the right branch.

```text
$ git branch
```

```text
* addFrance
  master
```

Next we will copy `united_states.txt` and change the name to the name of our chosen country.
Then we can use nano to edit the contents to reflect the info of your chosen country.  
Hint: You may need to do some internet searching to fill in the information.

```shell
$ cp united_states.txt france.txt
$ nano france.txt
$ cat france.txt
```

```text
Population: 66,991,000
Capital: Paris
```

Next let's add and commit the changes to the repo.

```shell
$ git add france.txt
$ git commit -m "Added file on france"
```

```text
[addFrance 79a312a] Added file on france
 1 file changed, 2 insertions(+), 2 deletions(-)
```

In some cases we may not have permission to push changes directly to the 
upstream/authoritative repo or we might like our changes to be reviewed regardless 
of permissions, so we'll create a `pull request`. 
A `pull request` is a **request** for a member of the upstream repository to **pull** 
our changes into the upstream repository from a `fork`, allowing them to request further 
changes/improvements and make comments on the changes before doing so. 
In order to create a `pull request`, we must push our new branch containing the
 changes we'd like to submit to the remote linked to our fork, `origin`, on GitHub.

```shell
$ git push origin addFrance
```

```text
Counting objects: 4, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 783 bytes | 0 bytes/s, done.
Total 4 (delta 3), reused 0 (delta 0)
remote: Resolving deltas: 100% (3/3), completed with 3 local objects.
To https://github.com/USERNAME/countries.git
   2037539..79a312a  addFrance -> addFrance
```

Next go to your forked github version of the repo and reload the page.
You won't see the new file added in the list of files but you will see 
that you recently pushed a new branch to the repository.

*TODO: Figure - Add France [../fig/github_screenshot_origin_master_addFrance.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_origin_master_addFrance.png)*


If you wish to view your new branch you can click on the 'Branch' drop down menu
and select that branch.

*TODO: Figure - Switch Branch [../fig/github_screenshot_switch_github_branch.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_switch_github_branch.png)*

Then you should be able to view the files and commits in that branch.

*TODO: Figure - Add France [../fig/github_screenshot_origin_master_addFrance.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_origin_master_addFrance.png)*

Github already suspects that we are going to want to make a pull request so we can click
the 'Compare & pull request' button to start a new pull request.

*TODO: Figure - Pull Request (Part 1) [../fig/github_screenshot_makingPR1.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_makingPR1.png)*

The base fork should be the upstream/authoritative version's master branch and then 
the head fork should be the new branch of our fork.
You can add more information into the comment section if there is anything you'd like 
to add for the person who reviews your suggestion.
Then you can click the 'create pull request button' to submit the pull request.

*TODO: Figure - Pull Request (Part 2) [../fig/github_screenshot_makingPR2.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_makingPR2.png)*

Now someone with privileges to the upstream repo can review it, give comments and
suggestions, and merge it into the upstream version.
In our pull request they can see any messages we left or click and look at the commits that were made and see the files changed.

Our collaborator reviewing the pull request noticed that 
we forgot to add the largest city so let's add it and update our pull request.

```shell
$ nano france.txt
$ cat france.txt
```

```text
Population: 66,991,000
Capital: Paris
Largest City: Paris
```

Next we will add and commit these changes.
Then we can push them to our fork of the repo.

```shell
$ git add france.txt
$ git commit -m "Added largest city to france file"
$ git push origin addFrance
```

```text
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 387 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/USERNAME/countries.git
   31aa2e3..609acfe  addFrance -> addFrance
```

If we reload the pull request, we'll see that the new commit was added to the 
pull request and the changes have been automatically updated.
New commits pushed to the same branch are included in the previous pull request.
If you want to suggest changes separately you need to make separate branches but 
if you want the changes to be considered together you should put them in the same branch.

*TODO: Figure - New Commit [../fig/github_screenshot_after_new_commit.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_after_new_commit.png)*

When working with others we might encounter the conflicts, which we
learned about earlier in branches.  Let's practice resolving conflicts when working
collaboratively.

We will continue to work in the `addFrance` branch from before and check we are
in that branch before we start.


```shell
$ git branch
```

```text
* addFrance
  master
```

Next we will each add our country to the existing `README.md` file in the repository in the line directly following the `Countries:` line.

```shell
$ nano README.md
$ cat README.md
```

```text
# countries
Sandbox for learning PR's in Software Carpentry workshop

Countries:
France
```

Next we need to add, commit, and push these requests to our existing pull request.

```shell
$ git add README.md
$ git commit -m "Added France to list of countries in README"
```

```text
[addFrance 66d7ebf] Added France to list of countries in README
 1 file changed, 1 insertions(+), 1 deletions(-)
```

```shell
$ git push origin addFrance
```

```text
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 376 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To https://github.com/USERNAME/countries.git
   609acfe..66d7ebf  addFrance -> addFrance
```

Now if we reload the page we had a pull request we notice that our `addFrance`
branch is conflicting with upstream's `master` branch.
This is because someone else edited the same line of the `README.md` file by 
adding 'United States' where we added 'France'.

*TODO: Figure - Conflicting PR [../fig/github_screenshot_conflicting_PR.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_conflicting_PR.png)*

In this case, it is possible to resolve this conflict in github by 
clicking the 'Resolve Conflicts' button.
However, we will reuse the skills we learned earlier to resolve this conflict locally,
as we did in our branching conflict.

First we need to pull down the changes from upstream's `master` branch into our
`addFrance` branch.

```shell
$ git pull upstream master
```

```text
From https://github.com/McMahonLab/countries
 * branch            master     -> FETCH_HEAD
Auto-merging README.md
CONFLICT (content): Merge conflict in README.md
Automatic merge failed; fix conflicts and then commit the result.
```

From the conflict error message we can see the conflict is in `README.md` or by running `git status` and seeing the 'both modified' status.

```shell
$ git status
```

```text
On branch addFrance
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

	both modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")
```

Now we will resolve the conflict by editing the `README.md` file to contain both 
'United States' and 'France' and none of the additional lines git added to
indicate conflict

```shell
$ nano README.md
$ cat README.md
```

```text
# countries
Sandbox for ComBEE github workshop on PR's

Countries:
France
United States
```

Then we add and commit our resolved conflict.

```shell
$ git add README.md
$ git commit -m "Resolved conflict in readme w two countries"
```

```text
[addFrance 912317b] Resolved conflict in readme w two countries
```

Finally we can update the pull request by pushing these changes to our github 
fork of the repository.

```shell
$ git push origin addFrance
```

```text
git push origin addFrance
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 732 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 1 local object.
To https://github.com/USERNAME/countries.git
   66d7ebf..912317b  addFrance -> addFrance
```

Now if we reload our browser we will see that the new commit is in the pull 
request and it has no conflicts with the base branch.

*TODO: Figure - Resolved Conflict [../fig/github_screenshot_resolved_PR_conflict.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_resolved_PR_conflict.png)*

Now the owner/administrator/manager of the authoritative repo can review our pull requests and decide to incorporate them.



## Exercises {#cmdline-git-exercises}

### Creating a repository


**Places to Create Git Repositories**

Along with tracking information about planets (the project we have already created), 
Dracula would also like to track information about moons.
Despite Wolfman's concerns, Dracula creates a `moons` project inside his `planets` 
project with the following sequence of commands:

```shell
$ cd ~/Desktop   # return to Desktop directory
$ cd planets     # go into planets directory, which is already a Git repository
$ ls -a          # ensure the .git sub-directory is still present in the planets directory
$ mkdir moons    # make a sub-directory planets/moons
$ cd moons       # go into moons sub-directory
$ git init       # make the moons sub-directory a Git repository
$ ls -a          # ensure the .git sub-directory is present indicating we have created a new Git repository
```

Is the `git init` command, run inside the `moons` sub-directory, required for 
tracking files stored in the `moons` sub-directory?
 
> *Solution*
>
> No. Dracula does not need to make the `moons` sub-directory a Git repository 
> because the `planets` repository will track all files, sub-directories, and 
> sub-directory files under the `planets` directory.  Thus, in order to track 
> all information about moons, Dracula only needed to add the `moons` sub-directory
> to the `planets` directory.
> 
> Additionally, Git repositories can interfere with each other if they are "nested":
> the outer repository will try to version-control
> the inner repository. Therefore, it's best to create each new Git
> repository in a separate directory. To be sure that there is no conflicting
> repository in the directory, check the output of `git status`. If it looks
> like the following, you are good to go to create a new repository as shown
> above:
>
> ```shell
> $ git status
> ```
>
> ```text
> fatal: Not a git repository (or any of the parent directories): .git
> ```


**Correcting `git init` Mistakes**

Wolfman explains to Dracula how a nested repository is redundant and may cause confusion
down the road. Dracula would like to remove the nested repository. How can Dracula undo 
his last `git init` in the `moons` sub-directory?

> *Background*
> 
> Removing files from a git repository needs to be done with caution. To remove files from the working tree and not from your working directory, use
> 
> ```shell
> $ rm filename
> ```
> 
> The file being removed has to be in sync with the branch head with no updates.
> If there are updates, the file can be removed by force by using the `-f` option.
> Similarly a directory can be removed from git using `rm -r dirname` or `rm -rf dirname`.
>
> *Solution - USE WITH CAUTION*
>
> Git keeps all of its files in the `.git` directory.
> To recover from this little mistake, Dracula can just remove the `.git`
> folder in the moons subdirectory by running the following command from inside the `planets` directory:
>
> ```shell
> $ rm -rf moons/.git
> ```
>
> But be careful! Running this command in the wrong directory, will remove
> the entire Git history of a project you might want to keep.
> Therefore, always check your current directory using the command `pwd`.


### Tracking changes


**Choosing a Commit Message**

Which of the following commit messages would be most appropriate for the
last commit made to `mars.txt`?

1. "Changes"
2. "Added line 'But the Mummy will appreciate the lack of humidity' to mars.txt"
3. "Discuss effects of Mars' climate on the Mummy"

> *Solution*
>
> Answer 1 is not descriptive enough, and the purpose of the commit is unclear;
> and answer 2 is redundant to using "git diff" to see what changed in this commit;
> but answer 3 is good: short, descriptive, and imperative.


**Committing Changes to Git**

Which command(s) below would save the changes of `myfile.txt`
to my local Git repository?

1. ```shell
   $ git commit -m "my recent changes"
   ```

2. ```shell
   $ git init myfile.txt
   $ git commit -m "my recent changes"
   ```

3. ```shell
   $ git add myfile.txt
   $ git commit -m "my recent changes"
   ```

4. ```shell
   $ git commit -m myfile.txt "my recent changes"
   ```

> *Solution*
>
> 1. Would only create a commit if files have already been staged.  
> 2. Would try to create a new repository.  
> 3. Is correct: first add the file to the staging area, then commit.  
> 4. Would try to commit a file "my recent changes" with the message myfile.txt.  


**Committing Multiple Files**

The staging area can hold changes from any number of files
that you want to commit as a single snapshot.

1. Add some text to `mars.txt` noting your decision
to consider Venus as a base

2. Create a new file `venus.txt` with your initial thoughts
about Venus as a base for you and your friends

3. Add changes from both files to the staging area,
and commit those changes.

> *Solution*
>
> First we make our changes to the `mars.txt` and `venus.txt` files:  
> ```shell
> $ nano mars.txt
> $ cat mars.txt
> ```
>
> ```text
> Maybe I should start with a base on Venus.
> ```
>
> ```shell
> $ nano venus.txt
> $ cat venus.txt
> ```
>
> ```text
> Venus is a nice planet and I definitely should consider it as a base.
> ```
>
> Now you can add both files to the staging area. We can do that in one line:
>
> ```shell
> $ git add mars.txt venus.txt
> ```
> 
> Or with multiple commands:  
>
> ```shell
> $ git add mars.txt
> $ git add venus.txt
> ```
>
> Now the files are ready to commit. You can check that using `git status`. If you are ready to commit use:
>
> ```shell
> $ git commit -m "Write plans to start a base on Venus"
> ```
> ```text
> [master cc127c2]
> Write plans to start a base on Venus
> 2 files changed, 2 insertions(+)
> create mode 100644 venus.txt
> ```

**`bio` Repository**

* Create a new Git repository on your computer called `bio`.  
* Write a three-line biography for yourself in a file called `me.txt`, commit your changes. 
* Modify one line, add a fourth line. 
* Display the differences between its updated state and its original state.  

> *Solution*
>
> If needed, move out of the `planets` folder:
>
> ```shell
> $ cd ..
> ```
>
> Create a new folder called `bio` and 'move' into it:
>
> ```shell
> $ mkdir bio
> $ cd bio
> ```
>
> Initialise git:
>
> ```shell
> $ git init
> ```
>
> Create your biography file `me.txt` using `nano` or another text editor.
> Once in place, add and commit it to the repository:
>
> ```shell
> $ git add me.txt
> $ git commit -m'Adding biography file'
> ```
>
> Modify the file as described (modify one line, add a fourth line).
> To display the differences
> between its updated state and its original state, use `git diff`:
>
> ```shell
> $ git diff me.txt
> ```


### Exploring history


**Recovering Older Versions of a File**

Jennifer has made changes to the Python script that she has been working on for weeks, and the
modifications she made this morning "broke" the script and it no longer runs. She has spent
~ 1hr trying to fix it, with no luck...

Luckily, she has been keeping track of her project's versions using Git! Which commands below will
let her recover the last committed version of her Python script called
`data_cruncher.py`?

1. `$ git checkout HEAD`

2. `$ git checkout HEAD data_cruncher.py`

3. `$ git checkout HEAD~1 data_cruncher.py`

4. `$ git checkout <unique ID of last commit> data_cruncher.py`

5. Both 2 and 4

> *Solution*
>
> The answer is (5)-Both 2 and 4. 
> 
> The `checkout` command restores files from the repository, overwriting the files in your working 
> directory. Answers 2 and 4 both restore the *latest* version *in the repository* of the file 
> `data_cruncher.py`. Answer 2 uses `HEAD` to indicate the *latest*, whereas answer 4 uses the 
> unique ID of the last commit, which is what `HEAD` means. 
> 
> Answer 3 gets the version of `data_cruncher.py` from the commit *before* `HEAD`, which is NOT 
> what we wanted.
> 
> Answer 1 can be dangerous! Without a filename, `git checkout` will restore **all files** 
> in the current directory (and all directories below it) to their state at the commit specified. 
> This command will restore `data_cruncher.py` to the latest commit version, but it will also 
> restore *any other files that are changed* to that version, erasing any changes you may 
> have made to those files!
> As discussed above, you are left in a *detached* `HEAD` state, and you don't want to be there.


**Reverting a Commit**

Jennifer is collaborating on her Python script with her colleagues and
realizes her last commit to the project's repository contained an error and
she wants to undo it.  `git revert [erroneous commit ID]` will create a new 
commit that reverses Jennifer's erroneous commit. Therefore `git revert` is
different to `git checkout [commit ID]` because `git checkout` returns the
files within the local repository to a previous state, whereas `git revert`
reverses changes committed to the local and project repositories.  
Below are the right steps and explanations for Jennifer to use `git revert`,
what is the missing command?

1. `________ # Look at the git history of the project to find the commit ID`

2. Copy the ID (the first few characters of the ID, e.g. 0b1d055).

3. `git revert [commit ID]`

4. Type in the new commit message.

5. Save and close


**Understanding Workflow and History**

What is the output of the last command in

```
$ cd planets
$ echo "Venus is beautiful and full of love" > venus.txt
$ git add venus.txt
$ echo "Venus is too hot to be suitable as a base" >> venus.txt
$ git commit -m "Comment on Venus as an unsuitable base"
$ git checkout HEAD venus.txt
$ cat venus.txt #this will print the contents of venus.txt to the screen
```

1. ```text
   Venus is too hot to be suitable as a base
   ```

2. ```
   Venus is beautiful and full of love
   ```

3. ```
   Venus is beautiful and full of love
   Venus is too hot to be suitable as a base
   ```

4. ```
   Error because you have changed venus.txt without committing the changes
   ```

> *Solution*
>
> The answer is 2. 
>  
> The command `git add venus.txt` places the current version of `venus.txt` into the staging area. 
> The changes to the file from the second `echo` command are only applied to the working copy, 
> not the version in the staging area.
>  
> So, when `git commit -m "Comment on Venus as an unsuitable base"` is executed, 
> the version of `venus.txt` committed to the repository is the one from the staging area and
> has only one line.
>   
> At this time, the working copy still has the second line (and 
> `git status` will show that the file is modified). However, `git checkout HEAD venus.txt` 
> replaces the working copy with the most recently committed version of `venus.txt`.
>   
>  So, `cat venus.txt` will output 
>  
>  ```text
>  Venus is beautiful and full of love.
>  ```


**Checking Understanding of `git diff`**

Consider this command: `git diff HEAD~9 mars.txt`. What do you predict this command
will do if you execute it? What happens when you do execute it? Why?

Try another command, `git diff [ID] mars.txt`, where [ID] is replaced with
the unique identifier for your most recent commit. What do you think will happen,
and what does happen?


**Getting Rid of Staged Changes**

`git checkout` can be used to restore a previous commit when unstaged changes have
been made, but will it also work for changes that have been staged but not committed?
Make a change to `mars.txt`, add that change, and use `git checkout` to see if
you can remove your change.


**Explore and Summarize Histories**

Exploring history is an important part of Git, often it is a challenge to find
the right commit ID, especially if the commit is from several months ago.

Imagine the `planets` project has more than 50 files.
You would like to find a commit with specific text in `mars.txt` is modified.
When you type `git log`, a very long list appeared,
How can you narrow down the search?

Recall that the `git diff` command allow us to explore one specific file,
e.g. `git diff mars.txt`. We can apply a similar idea here.

```shell
$ git log mars.txt
```

Unfortunately some of these commit messages are very ambiguous e.g. `update files`.
How can you search through these files?

Both `git diff` and `git log` are very useful and they summarize a different part of the history 
for you.
Is it possible to combine both? Let's try the following:

```shell
$ git log --patch mars.txt
```

You should get a long list of output, and you should be able to see both commit messages and 
the difference between each commit.

Question: What does the following command do?

```shell
$ git log --patch HEAD~9 *.txt
```


### Branches

TODO.


### Ignoring things

**Ignoring Nested Files**

Given a directory structure that looks like:

```shell
results/data
results/plots
```

How would you ignore only `results/plots` and not `results/data`?

> *Solution*
>
> If you only want to ignore the contents of
> `results/plots`, you can change your `.gitignore` to ignore
> only the `/plots/` subfolder by adding the following line to
> your .gitignore:
> 
> ```text
> results/plots/
> ```
>
> This line will ensure only the contents of `results/plots` is ignored, and
> not the contents of `results/data`.
> 
> As with most programming issues, there
> are a few alternative ways that one may ensure this ignore rule is followed.
> The "Ignoring Nested Files: Variation" exercise has a slightly
> different directory structure
> that presents an alternative solution.
> Further, the discussion page has more detail on ignore rules.


**Including Specific Files**

How would you ignore all `.dat` files in your root directory except for `final.dat`?

Hint: Find out what `!` (the exclamation point operator) does.

> *Solution*
> 
> You would add the following two lines to your .gitignore:
> 
> ```text
> *.dat           # ignore all data files
> !final.dat      # except final.data
> ```
>
> The exclamation point operator will include a previously excluded entry.
> 
> Note also that because you've previously committed `.dat` files in this
> lesson they will not be ignored with this new rule. Only future additions
> of `.dat` files added to the root directory will be ignored.


**Ignoring Nested Files: Variation**

Given a directory structure that looks similar to the earlier Nested Files
exercise, but with a slightly different directory structure,

```text
results/data
results/images
results/plots
results/analysis
```

How would you ignore all of the contents in the results folder, but not `results/data`?

Hint: think a bit about how you created an exception with the `!` operator before.

> *Solution*
>
> If you want to ignore the contents of
> `results/` but not those of `results/data/`, you can change your `.gitignore` to ignore
> the contents of results folder, but create an exception for the contents of the
> `results/data` subfolder. Your .gitignore would look like this:
> 
> ```text
> results/*               # ignore everything in results folder
> !results/data/          # do not ignore results/data/ contents
> ```


**Ignoring all data Files in a Directory**

Assuming you have an empty `.gitignore` file, and given a directory structure that looks like:

```
results/data/position/gps/a.dat
results/data/position/gps/b.dat
results/data/position/gps/c.dat
results/data/position/gps/info.txt
results/plots
```

What's the shortest `.gitignore` rule you could write to ignore all `.dat`
files in `result/data/position/gps`? Do not ignore the `info.txt`.

> *Solution*
>
> Appending `results/data/position/gps/*.dat` will match every file in `results/data/position/gps`
> that ends with `.dat`.
> The file `results/data/position/gps/info.txt` will not be ignored.


**The Order of Rules**

Given a `.gitignore` file with the following contents:

```text
*.dat
!*.dat
```

What will be the result?

> *Solution*
>
> The `!` modifier will negate an entry from a previously defined ignore pattern.
> Because the `!*.dat` entry negates all of the previous `.dat` files in the `.gitignore`,
> none of them will be ignored, and all `.dat` files will be tracked.


**Log Files**

You wrote a script that creates many intermediate log-files of the form `log_01`, `log_02`, `log_03`, etc.
You want to keep them but you do not want to track them through `git`.

1. Write **one** `.gitignore` entry that excludes files of the form `log_01`, `log_02`, etc.

2. Test your "ignore pattern" by creating some dummy files of the form `log_01`, etc.

3. You find that the file `log_01` is very important after all, add it to the tracked files without changing the `.gitignore` again.

4. Discuss with your neighbor what other types of files could reside in your directory that you do not want to track and thus would exclude via `.gitignore`.

> *Solution*
>
> 1. append either `log_*`  or  `log*`  as a new entry in your .gitignore
>
> 3. track `log_01` using   `git add -f log_01`


### Remotes in GitHub


**GitHub GUI**

Browse to your `planets` repository on GitHub.
Under the Code tab, find and click on the text that says "XX commits" (where "XX" is some number).
Hover over, and click on, the three buttons to the right of each commit.
What information can you gather/explore from these buttons?
How would you get that same information in the shell?

> *Solution*
>
> The left-most button (with the picture of a clipboard) copies the full identifier of the commit 
> to the clipboard. In the shell, ```git log``` will show you the full commit identifier for each 
> commit.
> 
> When you click on the middle button, you'll see all of the changes that were made in that 
> particular commit. Green shaded lines indicate additions and red ones removals. In the shell we 
> can do the same thing with ```git diff```. In particular, ```git diff ID1..ID2``` where ID1 and 
> ID2 are commit identifiers (e.g. ```git diff a3bf1e5..041e637```) will show the differences 
> between those two commits.
> 
> The right-most button lets you view all of the files in the repository at the time of that 
> commit. To do this in the shell, we'd need to checkout the repository at that particular time. 
> We can do this with ```git checkout ID``` where ID is the identifier of the commit we want to 
> look at. If we do this, we need to remember to put the repository back to the right state 
> afterwards!


**GitHub Timestamp**

Create a remote repository on GitHub. Push the contents of your local
repository to the remote. Make changes to your local repository and push these
changes. Go to the repo you just created on GitHub and check the
timestamps of the files. How does GitHub record times, and why?

> *Solution*
>
> GitHub displays timestamps in a human readable relative format (i.e. "22 hours ago" or "three 
> weeks ago"). However, if you hover over the timestamp, you can see the exact time at which the 
> last change to the file occurred.


**Push vs. Commit**

In this lesson, we introduced the "git push" command.
How is "git push" different from "git commit"?

> *Solution*
>
> When we push changes, we're interacting with a remote repository to update it with the changes 
> we've made locally (often this corresponds to sharing the changes we've made with others). 
> Commit only updates your local repository.


**GitHub License and README files**

In this section we learned about creating a remote repository on GitHub, but when you initialized 
your GitHub repo, you didn't add a README.md or a license file. If you had, what do you think 
would have happened when you tried to link your local and remote repositories?

> *Solution*
>
> In this case, we'd see a merge conflict due to unrelated histories. When GitHub creates a 
> README.md file, it performs a commit in the remote repository. When you try to pull the remote 
> repository to your local repository, Git detects that they have histories that do not share a 
> common origin and refuses to merge.
>
> ```shell
> $ git pull origin master
> ```
>
> ```text
> warning: no common commits
> remote: Enumerating objects: 3, done.
> remote: Counting objects: 100% (3/3), done.
> remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
> Unpacking objects: 100% (3/3), done.
> From https://github.com/vlad/planets
>  * branch            master     -> FETCH_HEAD
>  * [new branch]      master     -> origin/master
> fatal: refusing to merge unrelated histories
> ```
>
> You can force git to merge the two repositories with the option `--allow-unrelated-histories`. 
> Be careful when you use this option and carefully examine the contents of local and remote 
> repositories before merging.
>
> ```shell
> $ git pull --allow-unrelated-histories origin master
> ```
> 
> ```text
> From https://github.com/vlad/planets
>  * branch            master     -> FETCH_HEAD
> Merge made by the 'recursive' strategy.
> README.md | 1 +
> 1 file changed, 1 insertion(+)
> create mode 100644 README.md
> ```


### Collaborating

**Switch Roles and Repeat**

Switch roles and repeat the whole process.

**Review Changes**

The Owner pushed commits to the repository without giving any information
to the Collaborator. How can the Collaborator find out what has changed with
command line? And on GitHub?

> *Solution*
>
> On the command line, the Collaborator can use ```git fetch origin master```
> to get the remote changes into the local repository, but without merging
> them. Then by running ```git diff master origin/master``` the Collaborator
> will see the changes output in the terminal.
> 
> On GitHub, the Collaborator can go to their own fork of the repository and
> look right above the light blue latest commit bar for a gray bar saying
> "This branch is 1 commit behind Our-Repository:master." On the far right of
> that gray bar is a Compare icon and link. On the Compare page the
> Collaborator should change the base fork to their own repository, then click
> the link in the paragraph above to "compare across forks", and finally
> change the head fork to the main repository. This will show all the commits
> that are different.


### Conflicts

**Solving Conflicts that You Create**

Clone the repository created by your instructor.
Add a new file to it,
and modify an existing file (your instructor will tell you which one).
When asked by your instructor,
pull her changes from the repository to create a conflict,
then resolve it.

**Conflicts on Non-textual files**

What does Git do
when there is a conflict in an image or some other non-textual file
that is stored in version control?

> *Solution*
>
> Let's try it. Suppose Dracula takes a picture of Martian surface and
> calls it `mars.jpg`.
>
> If you do not have an image file of Mars available, you can create
> a dummy binary file like this:
>
> ```shell
> $ head --bytes 1024 /dev/urandom > mars.jpg
> $ ls -lh mars.jpg
> ```
>
> ```text
> -rw-r--r-- 1 vlad 57095 1.0K Mar  8 20:24 mars.jpg
> ```
>
> `ls` shows us that this created a 1-kilobyte file. It is full of
> random bytes read from the special file, `/dev/urandom`.
>
> Now, suppose Dracula adds `mars.jpg` to his repository:
>
> ```shell
> $ git add mars.jpg
> $ git commit -m "Add picture of Martian surface"
> ```
>
> ```text
> [master 8e4115c] Add picture of Martian surface
>  1 file changed, 0 insertions(+), 0 deletions(-)
>  create mode 100644 mars.jpg
> ```
>
> Suppose that Wolfman has added a similar picture in the meantime.
> His is a picture of the Martian sky, but it is *also* called `mars.jpg`.
> When Dracula tries to push, he gets a familiar message:
>
> ```shell
> $ git push origin master
> ```
>
> ```text
> To https://github.com/vlad/planets.git
>  ! [rejected]        master -> master (fetch first)
> error: failed to push some refs to 'https://github.com/vlad/planets.git'
> hint: Updates were rejected because the remote contains work that you do
> hint: not have locally. This is usually caused by another repository pushing
> hint: to the same ref. You may want to first integrate the remote changes
> hint: (e.g., 'git pull ...') before pushing again.
> hint: See the 'Note about fast-forwards' in 'git push --help' for details.
> ```
>
> We've learned that we must pull first and resolve any conflicts:
>
> ```shell
> $ git pull origin master
> ```
>
> When there is a conflict on an image or other binary file, git prints
> a message like this:
>
> ```shell
> $ git pull origin master
> remote: Counting objects: 3, done.
> remote: Compressing objects: 100% (3/3), done.
> remote: Total 3 (delta 0), reused 0 (delta 0)
> Unpacking objects: 100% (3/3), done.
> From https://github.com/vlad/planets.git
>  * branch            master     -> FETCH_HEAD
>    6a67967..439dc8c  master     -> origin/master
> warning: Cannot merge binary files: mars.jpg (HEAD vs. 439dc8c08869c342438f6dc4a2b615b05b93c76e)
> Auto-merging mars.jpg
> CONFLICT (add/add): Merge conflict in mars.jpg
> Automatic merge failed; fix conflicts and then commit the result.
> ```
>
> The conflict message here is mostly the same as it was for `mars.txt`, but
> there is one key additional line:
>
> ```text
> warning: Cannot merge binary files: mars.jpg (HEAD vs. 439dc8c08869c342438f6dc4a2b615b05b93c76e)
> ```
>
> Git cannot automatically insert conflict markers into an image as it does
> for text files. So, instead of editing the image file, we must check out
> the version we want to keep. Then we can add and commit this version.
>
> On the key line above, Git has conveniently given us commit identifiers
> for the two versions of `mars.jpg`. Our version is `HEAD`, and Wolfman's
> version is `439dc8c0...`. If we want to use our version, we can use
> `git checkout`:
> 
> ```shell
> $ git checkout HEAD mars.jpg
> $ git add mars.jpg
> $ git commit -m "Use image of surface instead of sky"
> ```
>
> ```text
> [master 21032c3] Use image of surface instead of sky
> ```
>
> If instead we want to use Wolfman's version, we can use `git checkout` with
> Wolfman's commit identifier, `439dc8c0`:
>
> ```shell
> $ git checkout 439dc8c0 mars.jpg
> $ git add mars.jpg
> $ git commit -m "Use image of sky instead of surface"
> ```
> 
> ```text
> [master da21b34] Use image of sky instead of surface
> ```
>
> We can also keep *both* images. The catch is that we cannot keep them
> under the same name. But, we can check out each version in succession
> and *rename* it, then add the renamed versions. First, check out each
> image and rename it:
>
> ```shell
> $ git checkout HEAD mars.jpg
> $ git mv mars.jpg mars-surface.jpg
> $ git checkout 439dc8c0 mars.jpg
> $ mv mars.jpg mars-sky.jpg
> ```
>
> Then, remove the old `mars.jpg` and add the two new files:
>
> ```shell
> $ git rm mars.jpg
> $ git add mars-surface.jpg
> $ git add mars-sky.jpg
> $ git commit -m "Use two images: surface and sky"
> ```
>
> ```text
> [master 94ae08c] Use two images: surface and sky
>  2 files changed, 0 insertions(+), 0 deletions(-)
>  create mode 100644 mars-sky.jpg
>  rename mars.jpg => mars-surface.jpg (100%)
> ```
>
> Now both images of Mars are checked into the repository, and `mars.jpg`
> no longer exists.


**A Typical Work Session**

You sit down at your computer to work on a shared project that is tracked in a
remote Git repository. During your work session, you take the following
actions, but not in this order:

* *Make changes* by appending the number `100` to a text file `numbers.txt`
* *Update remote* repository to match the local repository
* *Celebrate* your success with beer(s)
* *Update local* repository to match the remote repository
* *Stage changes* to be committed
* *Commit changes* to the local repository

In what order should you perform these actions to minimize the chances of
conflicts? Put the commands above in order in the *action* column of the table below.
When you have the order right,
see if you can write the corresponding commands in the *command* column.
A few steps are populated to get you started.

|order|action . . . . . . . . . . |command . . . . . . . . . . |
|-----|---------------------------|----------------------------|
|1    |                           |                            |
|2    |                           | `echo 100 >> numbers.txt`  |
|3    |                           |                            |
|4    |                           |                            |
|5    |                           |                            |
|6    | Celebrate!                | `AFK`                      |

> *Solution*
>
> |order|action . . . . . . |command . . . . . . . . . . . . . . . . . . . |
> |-----|-------------------|----------------------------------------------|
> |1    | Update local      | `git pull origin master`                     |
> |2    | Make changes      | `echo 100 >> numbers.txt`                    |
> |3    | Stage changes     | `git add numbers.txt`                        |
> |4    | Commit changes    | `git commit -m "Add 100 to numbers.txt"`     |
> |5    | Update remote     | `git push origin master`                     |
> |6    | Celebrate!        | `AFK`                                        |


### Pull requests

**Add new country file and make additional PR**

* Starting in the master branch make a new branch
* Copy other country file into a new country
* Edit the file to include info on the new country
* Add and commit this new file
* Push the new changes to github

> *Solution*
> 
> ```shell
> $ git checkout master
> $ git checkout -b addItaly
> $ cp united_states.txt italy.txt
> $ nano italy.txt #Add the right info into the file
> $ git add italy.txt
> $ git commit -m "Added file on Italy"
> $ git push origin addItaly
> ```


## Key Points {#cmdline-git-keypoints}

```{r, child="keypoints/cmdline-git.md"}
```

```{r, child="./links.md"}
```