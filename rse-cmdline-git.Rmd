# Git at the command line {#rse-cmdline-git}

## Questions {#rse-cmdline-git-questions}

```{r, child="questions/rse-cmdline-git.md"}
```

## Objectives {#rse-cmdline-git-objectives}

```{r, child="objectives/rse-cmdline-git.md"}
```

## Introduction {#rse-cmdline-git-intro}

In a previous lesson (TODO: provide link),
we learned the basics of Git using a graphical interface (GitKraken or R Studio).
Like many computer programs,
using Git at the command line is a potentially more powerful option,
as it allows you to access all the features.
This chapter describes how the basic "add, commit, push, pull" cycle works at the command line,
before introducing new concepts including branching and pull requests.


## Setting up Git {#rse-cmdline-git-setup}

When we use Git at the command line for the first time,
we need to configure a few things. 

On a command line, Git commands are written as `git verb options`,
where `verb` is what we actually want to do
and `options` is additional optional information which may be needed for the `verb`.
So here is how Dracula sets up his new laptop:

```shell
$ git config --global user.name "Vlad Dracula"
$ git config --global user.email "vlad@tran.sylvan.ia"
```

(Please use your own name and email address instead of Dracula's.)

For these lessons we will be interacting with [GitHub](https://github.com/),
so the email address should be the same as the one used when setting up your GitHub account.

The commands we just ran above only need to be run once: the flag `--global` tells Git
to use the settings for every project, in your user account, on this computer.
You can re-run them at any time if you want to change your details.

You can also check your settings at any time:

```shell
$ git config --list
```

> **Git Help and Manual**
>
> Always remember that if you forget a `git` command,
> you can access the list of commands by using `-h` and access the Git manual by using `--help` :
>
> ```shell
> $ git config -h
> $ git config --help
> ```


## Creating a repository {#rse-cmdline-git-repos}

Once Git is configured,
we can start using it.

We will continue with the story of Wolfman and Dracula who are investigating if it
is possible to send a planetary lander to Mars. 

*TODO: Figure - Motivating Example [../fig/motivatingexample.png](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/motivatingexample.png)*

First, let's create a directory in `Desktop` folder for our work and then move into that directory:

```shell
$ cd ~/Desktop
$ mkdir planets
$ cd planets
```

Then we tell Git to make `planets` a repository — a place where Git can store versions of our files:

```shell
$ git init
```

It is important to note that `git init` will create a repository that
includes subdirectories and their files---there is no need to create
separate repositories nested within the `planets` repository,
whether subdirectories are present from the beginning or added later.
Also, note that the creation of the `planets` directory and its initialization as a
repository are completely separate processes.

If we use `ls` to show the directory's contents,
it appears that nothing has changed:

```shell
$ ls
```

But if we add the `-a` flag to show everything,
we can see that Git has created a hidden directory within `planets` called `.git`:

```shell
$ ls -a
```

```text
.	..	.git
```

Git uses this special sub-directory to store all the information about the project, 
including all files and sub-directories located within the project's directory.
If we ever delete the `.git` sub-directory,
we will lose the project's history.

We can check that everything is set up correctly
by asking Git to tell us the status of our project:

```shell
$ git status
```

```text
# On branch master
#
# Initial commit
#
nothing to commit (create/copy files and use "git add" to track)
```

If you are using a different version of `git`, the exact
wording of the output might be slightly different.


## Tracking changes {#rse-cmdline-git-changes}

Now that we've set everything up,
we can go ahead and start using Git to track changes in our work.
Most of the commands (e.g. `git add`, `git commit`) will sound familiar,
as the same terminology is used in graphical interfaces like GitKraken and R Studio.

To start, let's make sure we're still in the right directory.
You should be in the `planets` directory.

```shell
$ cd ~/Desktop/planets
```

Let's create a file called `mars.txt` that contains some notes
about the Red Planet's suitability as a base.

Using any text editor you like,
type the text below into the `mars.txt` file:

```text
Cold and dry, but everything is my favorite color
```

If we check the status of our project again,
Git tells us that it's noticed the new file:

```shell
$ git status
```

```text
On branch master

Initial commit

Untracked files:
   (use "git add <file>..." to include in what will be committed)

	mars.txt
nothing added to commit but untracked files present (use "git add" to track)
```

The "untracked files" message means that there's a file in the directory
that Git isn't keeping track of.
We can tell Git to track a file using `git add`:

```shell
$ git add mars.txt
```

and then check that the right thing happened:

```shell
$ git status
```

```text
On branch master

Initial commit

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

	new file:   mars.txt

```

Git now knows that it's supposed to keep track of `mars.txt`,
but it hasn't recorded these changes as a commit yet.
To get it to do that,
we need to run one more command:

```shell
$ git commit -m "Start notes on Mars as a base"
```

```text
[master (root-commit) f22b25e] Start notes on Mars as a base
 1 file changed, 1 insertion(+)
 create mode 100644 mars.txt
```

When we run `git commit`,
Git takes everything we have told it to save by using `git add`
and stores a copy permanently inside the special `.git` directory.
This permanent copy is called a **commit**
(or **revision**) and its short identifier is `f22b25e`.
Your commit may have another identifier.

We use the `-m` flag (for "message")
to record a short, descriptive, and specific comment that will help us remember later on what we did and why.
If we just run `git commit` without the `-m` option,
Git will launch `nano`
(or whatever other default editor was configured using `git config --global core.editor`)
so that we can write a longer message.

If we run `git status` now:

```shell
$ git status
```

```text
On branch master
nothing to commit, working directory clean
```

it tells us everything is up to date.
If we want to know what we've done recently,
we can ask Git to show us the project's history using `git log`:

```shell
$ git log
```

```text
commit f22b25e3233b4645dabd0d81e651fe074bd8e73b
Author: Vlad Dracula <vlad@tran.sylvan.ia>
Date:   Thu Aug 22 09:51:46 2013 -0400

    Start notes on Mars as a base
```

`git log` lists all commits  made to a repository in reverse chronological order.
The listing for each commit includes
the commit's full identifier
(which starts with the same characters as
the short identifier printed by the `git commit` command earlier),
the commit's author,
when it was created,
and the log message Git was given when the commit was created.

> **Where Are My Changes?**
>
> If we run `ls` at this point, we will still see just one file called `mars.txt`.
> That's because Git saves information about files' history
> in the special `.git` directory mentioned earlier
> so that our filesystem doesn't become cluttered
> (and so that we can't accidentally edit or delete an old version).

Now suppose Dracula adds more information to the file:

```text
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
```

When we run `git status` now,
it tells us that a file it already knows about has been modified:

```shell
$ git status
```

```text
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   mars.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

The last line is the key phrase:
"no changes added to commit".
We have changed this file,
but we haven't told Git we will want to save those changes
(which we do with `git add`)
nor have we saved them (which we do with `git commit`).
So let's do that now. It is good practice to always review
our changes before saving them. We do this using `git diff`.
This shows us the differences between the current state
of the file and the most recently saved version:

```shell
$ git diff
```

```text
diff --git a/mars.txt b/mars.txt
index df0654a..315bf3a 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1 +1,2 @@
 Cold and dry, but everything is my favorite color
+The two moons may be a problem for Wolfman
```

The output is cryptic because
it is actually a series of commands for tools like editors and `patch`
telling them how to reconstruct one file given the other.
If we break it down into pieces:

1.  The first line tells us that Git is producing output similar to the Unix `diff` command
    comparing the old and new versions of the file.
2.  The second line tells exactly which versions of the file
    Git is comparing;
    `df0654a` and `315bf3a` are unique computer-generated labels for those versions.
3.  The third and fourth lines once again show the name of the file being changed.
4.  The remaining lines are the most interesting, they show us the actual differences
    and the lines on which they occur.
    In particular,
    the `+` marker in the first column shows where we added a line.

After reviewing our change, it's time to commit it:

```shell
$ git commit -m "Add concerns about effects of Mars' moons on Wolfman"
$ git status
```

```text
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   mars.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

Whoops:
Git won't commit because we didn't use `git add` first.
Let's fix that:

```shell
$ git add mars.txt
$ git commit -m "Add concerns about effects of Mars' moons on Wolfman"
```

```text
[master 34961b1] Add concerns about effects of Mars' moons on Wolfman
 1 file changed, 1 insertion(+)
```

> **Ignoring things**
>
> We're only working with one file so far (`mars.txt`),
> but what if we had lots of files in this directory?
> We might want to have git track our text (`.txt`) files, for instance,
> but not our data files (`.dat`).
>
> So that those data files don't show up as "untracked files" every time we call `git status`,
> we can create a file in the root directory of our project called `.gitignore`.
> In this file we can list all the files we want git to ignore.
> For example, we could add the line `*.dat` to `.gitignore` to ignore all the data files.
> 
> Don't forget to add and commit the `.gitignore` file to your repository so that git
> knows to use it!


## Remotes in GitHub {#rse-cmdline-git-remotes}

One of the first things we did when learning Git via GitKraken or R Studio
was to link our local repository with an external hosting service (GitHub).
We will do that again here,
so login to GitHub and create a new repository called `planets`.

The next step is to connect the two repositories.
We do this by making the GitHub repository a remote for the local repository.
The home page of the repository on GitHub includes the string we need to
identify it:

*TODO: Figure - Where to Find Repository URL on GitHub [../fig/github-find-repo-string.png](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/github-find-repo-string.png)*

Click on the 'HTTPS' link to change the protocol from SSH to HTTPS.

> **HTTPS vs. SSH**
>
> We use HTTPS here because it does not require additional configuration.  After
> the workshop you may want to set up SSH access, which is a bit more secure, by
> following one of the great tutorials from
> [GitHub](https://help.github.com/articles/generating-ssh-keys),
> [Atlassian/Bitbucket](https://confluence.atlassian.com/bitbucket/set-up-ssh-for-git-728138079.html)
> and [GitLab](https://about.gitlab.com/2014/03/04/add-ssh-key-screencast/)
> (this one has a screencast).

*TODO: Figure - Changing the Repository URL on GitHub [../fig/github-change-repo-string.png](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/github-change-repo-string.png)*

Copy that URL from the browser, go into the local `planets` repository, and run
this command:

```shell
$ git remote add origin https://github.com/vlad/planets.git
```

Make sure to use the URL for your repository rather than Vlad's: the only
difference should be your username instead of `vlad`.

`origin` is a local name used to refer to the remote repository. It could be called
anything, but `origin` is a convention that is often used by default in git
and GitHub, so it's helpful to stick with this unless there's a reason not to.

We can check that the command has worked by running `git remote -v`:

```shell
$ git remote -v
```

```text
origin   https://github.com/vlad/planets.git (push)
origin   https://github.com/vlad/planets.git (fetch)
```

Once the remote is set up, this command will push the changes from
our local repository to the repository on GitHub:

```shell
$ git push origin master
```

```text
Enumerating objects: 16, done.
Counting objects: 100% (16/16), done.
Delta compression using up to 8 threads.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (16/16), 1.45 KiB | 372.00 KiB/s, done.
Total 16 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), done.
To https://github.com/vlad/planets.git
 * [new branch]      master -> master
```

> **Proxy**
>
> If the network you are connected to uses a proxy, there is a chance that your
> last command failed with "Could not resolve hostname" as the error message. To
> solve this issue, you need to tell Git about the proxy:
>
> ```shell
> $ git config --global http.proxy http://user:password@proxy.url
> $ git config --global https.proxy http://user:password@proxy.url
> ```
>
> When you connect to another network that doesn't use a proxy, you will need to
> tell Git to disable the proxy using:
>
> ```shell
> $ git config --global --unset http.proxy
> $ git config --global --unset https.proxy
> ```

> **Password Managers**
>
> If your operating system has a password manager configured, `git push` will
> try to use it when it needs your username and password.  For example, this
> is the default behavior for Git Bash on Windows. If you want to type your
> username and password at the terminal instead of using a password manager,
> type:
>
> ```shell
> $ unset SSH_ASKPASS
> ```
>
> in the terminal, before you run `git push`.  Despite the name, [Git uses
> `SSH_ASKPASS` for all credential
> entry](https://git-scm.com/docs/gitcredentials#_requesting_credentials), so
> you may want to unset `SSH_ASKPASS` whether you are using Git via SSH or
> https.
>
> You may also want to add `unset SSH_ASKPASS` at the end of your `~/.bashrc`
> to make Git default to using the terminal for usernames and passwords.

> **The '-u' Flag**
>
> You may see a `-u` option used with `git push` in some documentation.  This
> option is synonymous with the `--set-upstream-to` option for the `git branch`
> command, and is used to associate the current branch with a remote branch so
> that the `git pull` command can be used without any arguments. To do this,
> simply use `git push -u origin master` once the remote has been set up.

We can pull changes from the remote repository to the local one as well:

```shell
$ git pull origin master
```

```text
From https://github.com/vlad/planets
 * branch            master     -> FETCH_HEAD
Already up-to-date.
```

Pulling has no effect in this case because the two repositories are already
synchronized.


## Exploring history {#rse-cmdline-git-history}

Now that we've linked up with GitHub,
we can resume work on `mars.txt`.

As we saw in a previous section, we can refer to commits by their identifiers.
You can refer to the most recent commit of the working directory by using the identifier `HEAD`.

We've been adding one line at a time to `mars.txt`,
so it's easy to track our progress by looking, so let's do that using our `HEAD`s.
Before we start,
let's make a change to `mars.txt`, adding yet another line.

```text
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
An ill-considered change
```

Now, let's see what we get.

```shell
$ git diff HEAD mars.txt
```

```text
diff --git a/mars.txt b/mars.txt
index b36abfd..0848c8d 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1,3 +1,4 @@
 Cold and dry, but everything is my favorite color
 The two moons may be a problem for Wolfman
+An ill-considered change.
```

which is the same as what you would get if you leave out `HEAD` (try it).
The real goodness in all this is when you can refer to previous commits.
We do that by adding `~1` 
(where "~" is "tilde", pronounced [**til**-d*uh*]) 
to refer to the commit one before `HEAD`.

```shell
$ git diff HEAD~1 mars.txt
```

If we want to see the differences between older commits we can use `git diff`
again, but with the notation `HEAD~1`, `HEAD~2`, and so on, to refer to them:

```shell
$ git diff HEAD~2 mars.txt
```

```text
diff --git a/mars.txt b/mars.txt
index df0654a..b36abfd 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1 +1,4 @@
 Cold and dry, but everything is my favorite color
+The two moons may be a problem for Wolfman
+An ill-considered change
```

We could also use `git show` which shows us what changes we made at an older commit as 
well as the commit message, rather than the _differences_ between a commit and our 
working directory that we see by using `git diff`.

```shell
$ git show HEAD~2 mars.txt
```

```text
commit f22b25e3233b4645dabd0d81e651fe074bd8e73b
Author: Vlad Dracula <vlad@tran.sylvan.ia>
Date:   Thu Aug 22 09:51:46 2013 -0400

    Start notes on Mars as a base

diff --git a/mars.txt b/mars.txt
new file mode 100644
index 0000000..df0654a
--- /dev/null
+++ b/mars.txt
@@ -0,0 +1 @@
+Cold and dry, but everything is my favorite color
```

In this way,
we can build up a chain of commits.
The most recent end of the chain is referred to as `HEAD`;
we can refer to previous commits using the `~` notation,
so `HEAD~1`
means "the previous commit",
while `HEAD~123` goes back 123 commits from where we are now.

We can also refer to commits using
those long strings of digits and letters
that `git log` displays.
These are unique IDs for the changes,
and "unique" really does mean unique:
every change to any set of files on any computer
has a unique 40-character identifier.
Our first commit was given the ID
`f22b25e3233b4645dabd0d81e651fe074bd8e73b`,
so let's try this:

```shell
$ git diff f22b25e3233b4645dabd0d81e651fe074bd8e73b mars.txt
```

```text
diff --git a/mars.txt b/mars.txt
index df0654a..93a3e13 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1 +1,4 @@
 Cold and dry, but everything is my favorite color
+The two moons may be a problem for Wolfman
+An ill-considered change
```

That's the right answer,
but typing out random 40-character strings is annoying,
so Git lets us use just the first few characters:

```shell
$ git diff f22b25e mars.txt
```

```text
diff --git a/mars.txt b/mars.txt
index df0654a..93a3e13 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1 +1,4 @@
 Cold and dry, but everything is my favorite color
+The two moons may be a problem for Wolfman
+An ill-considered change
```

All right!
So we can save changes to files and see what we've changed—now how
can we restore older versions of things?
Let's suppose we change our mind about the last update to
`mars.txt` (the "ill-considered change").

`git status` now tells us that the file has been changed,
but those changes haven't been staged:

```shell
$ git status
```

```text
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   mars.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

We can put things back the way they were
by using `git checkout`:

```shell
$ git checkout HEAD mars.txt
$ cat mars.txt
```

```text
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
```

As you might guess from its name,
`git checkout` checks out (i.e., restores) an old version of a file.
In this case,
we're telling Git that we want to recover the version of the file recorded in `HEAD`,
which is the last saved commit.
If we want to go back even further,
we can use a commit identifier instead:

```shell
$ git checkout f22b25e mars.txt
```

```shell
$ cat mars.txt
```

```text
Cold and dry, but everything is my favorite color
```

```shell
$ git status
```

```text
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   mars.txt

```

Notice that the changes are on the staged area.
Again, we can put things back the way they were
by using `git checkout`:

```shell
$ git checkout HEAD mars.txt
```

> **Don't Lose Your HEAD**
>
> Above we used
>
> ```shell
> $ git checkout f22b25e mars.txt
> ```
>
> to revert `mars.txt` to its state after the commit `f22b25e`. But be careful! 
> The command `checkout` has other important functionalities and Git will misunderstand
> your intentions if you are not accurate with the typing. For example, 
> if you forget `mars.txt` in the previous command.
>
> ```shell
> $ git checkout f22b25e
> ```
>
> ```text
> Note: checking out 'f22b25e'.
>
> You are in 'detached HEAD' state. You can look around, make experimental
> changes and commit them, and you can discard any commits you make in this
> state without impacting any branches by performing another checkout.
>
> If you want to create a new branch to retain commits you create, you may
> do so (now or later) by using -b with the checkout command again. Example:
>
>  git checkout -b <new-branch-name>
>
> HEAD is now at f22b25e Start notes on Mars as a base
> ```
>
> The "detached HEAD" is like "look, but don't touch" here,
> so you shouldn't make any changes in this state.
> After investigating your repo's past state, reattach your `HEAD` with `git checkout master`.



*TODO: Figure - Git Checkout [../fig/git-checkout.svg](https://github.com/swcarpentry/git-novice/blob/gh-pages/fig/git-checkout.svg)*


> **Simplifying the Common Case**
>
> If you read the output of `git status` carefully,
> you'll see that it includes this hint:
>
> ```shell
> (use "git checkout -- <file>..." to discard changes in working directory)
> ```
>
> As it says,
> `git checkout` without a version identifier restores files to the state saved in `HEAD`.
> The double dash `--` is needed to separate the names of the files being recovered
> from the command itself:
> without it,
> Git would try to use the name of the file as the commit identifier.

The fact that files can be reverted one by one
tends to change the way people organize their work.
If everything is in one large document,
it's hard (but not impossible) to undo changes to the introduction
without also undoing changes made later to the conclusion.
If the introduction and conclusion are stored in separate files,
on the other hand,
moving backward and forward in time becomes much easier.


## Branches {#rse-cmdline-git-branches}

*FIXME: This lesson is from [UW-Madison](https://uw-madison-datascience.github.io/git-novice-custom/07-branches/)
and therefore doesn't quite match the storyline of the other lessons.*

So far we've always been working in a straight timeline.
However, there are times when we might want to keep
our main work safe from experimental changes we are working on.
To do this we can use branches to work on separate tasks in parallel
without changing our current branch, `master`.

We didn't see it before but the first branch made is called `master`.
This is the default branch created when initializing a repository and
is often considered to be the "clean" or "working" version of a
repository's code.

We can see what branches exist in a repository by typing

```shell
$ git branch
```

```text
* master
```

The '*' indicates which branch we are currently on.

In this lesson, Dracula is trying to run an analysis
and doesn't know if it will be faster in bash or python.
To keep his master branch safe he will use separate branches
for both bash and python analysis.
Then he will merge the branch with the faster script
into his master branch.

First let's make the python branch.
We use the same `git branch` command but now add the 
name we want to give our new branch

```shell
$ git branch pythondev
```

We can now check our work with the `git branch` command.

```shell
$ git branch
```

```text
* master
  pythondev
```

We can see that we created the `pythondev` branch but we
are still in the master branch.

We can also see this in the output of the `git status` command.

```shell
$ git status
```

```text
On branch master
nothing to commit, working directory clean
```

To switch to our new branch we can use the `checkout` command
we learned earlier and check our work with `git branch`.

```shell
$ git checkout pythondev
$ git branch
```

```text
  master
* pythondev
```

Before we used the `checkout` command to checkout a file from a specific commit
using commit hashes or `HEAD` and the filename (`git checkout HEAD <file>`). The
`checkout` command can also be used to checkout an entire previous version of the
repository, updating all files in the repository to match the state of a desired commit.

Branches allow us to do this using a human-readable name rather than memorizing
a commit hash. This name also typically gives purpose to the set of changes in
that branch. When we use the command `git checkout <branch_name>`, we are using
a nickname to checkout a version of the repository that matches the most recent
commit in that branch (a.k.a. the HEAD of that branch).

Here you can use `git log` and `ls` to see that the history and 
files are the same as our `master` branch. This will be true until
some changes are committed to our new branch.

Now lets make our python script.  
For simplicity sake, we will `touch` the script making an empty file
but imagine we spent hours working on this python script for our analysis.

```shell
$ touch analysis.py
```

Now we can add and commit the script to our branch.

```shell
$ git add analysis.py
$ git commit -m "Wrote and tested python analysis script"
```

```text
[pythondev x792csa1] Wrote and tested python analysis script
 1 file changed, 1 insertion(+)
 create mode 100644 analysis.py
```

Lets check our work!

```shell
$ ls
$ git log --oneline
```

As expected, we see our commit in the log.

Now let's switch back to the `master` branch.

```shell
$ git checkout master
$ git branch
```

```text
* master
  pythondev
```

Let's explore the repository a bit.

Now that we've confirmed we are on the `master` branch again.
Let's confirm that `analysis.py` and our last commit aren't in `master`.

```shell
$ ls
$ git log --oneline
```

We no longer see the file `analysis.py` and our latest commit doesn't
appear in this branch's history. But do not fear! All of our hard work
remains in the `pythondev` branch. We can confirm this by moving back
to that branch.

```shell
$ git checkout pythondev
$ git branch
```

```text
  master
* pythondev
```

```shell
$ ls
$ git log --oneline
```

And we see that our `analysis.py` file and respective commit have been
preserved in the `pythondev` branch.

Now we can repeat the process for our bash script in a branch called
`bashdev`.

First we must checkout the `master` branch again. New branches will
include the entire history up to the current commit, and we'd like
to keep these two tasks separate.

```shell
$ git checkout master
$ git branch
```

```text
* master
  pythondev
```

This time let's create and switch two the `bashdev` branch
in one command.

We can do so by adding the `-b` flag to checkout.

```shell
$ git checkout -b bashdev
$ git branch
```

```text
* bashdev
  master
  pythonndev
```

We can use `ls` and `git log` to see that this branch is 
the same as our current `master` branch.

Now we can make `analysis.sh` and add and commit it.
Again imagine instead of `touch`ing the file we worked 
on it for many hours.

```shell
$ touch analysis.sh
$ git add analysis.sh
$ git commit –m “Wrote and tested bash analysis script”
```

```text
[bashdev 2n779ds] Wrote and tested bash analysis script
 1 file changed, 1 insertion(+)
 create mode 100644 analysis.sh
```

Lets check our work again before we switch back to the master branch.

```shell
$ ls
$ git log --oneline
```

So it turns out the python `analysis.py` is much faster than `analysis.sh`.

Let's merge this version into our `master` branch so we can use it for
our work going forward.

Merging brings the changes from a different branch into 
the current branch.

First we must switch to the branch we're merging changes into, `master`.

```shell
$ git checkout master
$ git branch
```

```text
  bashdev
* master
  pythonndev
```

Now we can `merge` the `pythondev` branch into our current branch
(`master`). In english, this command could be stated as "`git`, please
`merge` the changes in the `pythondev` branch into the current branch
I'm in".

```shell
$ git merge pythondev
```

```text
Updating 12687f6..x792csa1
Fast-forward
 analysis.py | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 analysis.py
```

Now that we've merged the `pythondev` into `master`, these changes
exist in both branches. This could be confusing in the future if we
stumble upon the `pythondev` branch again.

We can delete our old branches so as to avoid this confusion later.
We can do so by adding the `-d` flag to the `git branch` command.

```shell
git branch -d pythondev
```

```text
Deleted branch pythondev (was x792csa1).
```

And because we don't want to keep the changes in the `bashdev` branch,
we can delete the `bashdev` branch as well

```shell
$ git branch -d bashdev
```

```text
error: The branch 'bashdev' is not fully merged.
If you are sure you want to delete it, run 'git branch -D bashdev'.
```

Since we've never merged the changes from the `bashdev` branch,
git warns us about deleting them and tells us to use the `-D` flag instead.

Since we really want to delete this branch we will go ahead and do so.

```shell
git branch -D bashdev
```

```text
Deleted branch bashdev (was 2n779ds).
```


## A branching workflow {#rse-cmdline-git-branching-workflow}

Now that we're comfortable with creating and merging branches,
we need to consider when and how we might use branches in our code development workflows.

Experienced developers tend to use a "branch-per-feature" workflow,
even when they are working on their own.
Whenever they want to create a new feature,
they create a new branch from `master` and do the work there.
When it's done,
they merge that branch back into `master.

In the context of what we've learned about branches so far,
our branch-per-feature workflow looks like this:

1.  `git checkout master` to make sure you're working in the `master` branch.

2.  `git pull origin master` to make sure that
    your starting point is up to date
    (i.e., that the changes you committed while working on the cluster yesterday are now in your local copy,
    or that the fix your colleague did last week has been incorporated).

3.  <code>git checkout -b <em>name-of-feature</em></code> to create a new branch.
    The branch's name should be as descriptive as the name of a function
    or of a file containing source code:
    `"stuff"` or `"fixes"` saves you a couple of seconds of typing when you create the branch,
    and will cost you much more time than that later on
    when you're juggling half a dozen branches
    and trying to figure out what's in each.

4.  Do the work you want to do.
    If some other task occurs to you while you're doing it---for example,
    if you're writing a new function and realize that the documentation for some other function should be updated---*don't*
    do that work in this branch just because you happen to be there.
    Instead,
    commit your changes,
    switch back to `master`,
    create a new branch for the other work,
    and carry on.

5.  Periodically,
    you may <code>git push origin <em>name-of-feature</em></code> to save your work to GitHub.

6.  When the work is done,
    you `git pull origin master` to get any changes that anyone else has put in the master copy
    into your branch
    and merge any conflicts.
    This is an important step:
    you want to do the merge *and test that everything still works* in *your* branch,
    not in `master`.

7.  Finally,
    use `git checkout master` to switch back to the `master` branch on your machine
    and <code>git merge <em>name-of-feature</em> master</code> to merge your changes into `master`.
    Test it one more time,
    and then `git push origin master` to send your changes to the remote repository
    for everyone else to admire and use.


### What *is* a feature?

But what is a "feature", exactly?
What's large enough to merit creation of a new branch?
These rules make sense for small projects with or without collaborators:

1.  Anything cosmetic that is only one or two lines long can be done in `master` and committed right away.
    "Cosmetic" means changes to comments or documentation:
    nothing that affects how code runs---not even a simple variable renaming---is done this way,
    because experience has taught that things that aren't supposed to often do.

2.  A pure addition that doesn't change anything else is a feature and goes into a branch.
    For example,
    if you run a new analysis and save the results,
    that should be done on its own branch
    because it might take several tries to get the analysis to run,
    and you might interrupt yourself several times to fix things that you've discovered aren't working.

3.  Every change to code that someone might want to undo later in one step gets done as a feature.
    For example,
    if a parameter is added to a function,
    every call to the function has to be updated;
    since neither alteration makes sense without the other,
    it's considered a single feature and should be done in one branch.

The hardest thing about using a branch-per-feature workflow is actually doing it for small changes.
As the first point in the list above suggests,
most people are pragmatic about this on small projects;
on large ones,
where dozens of people might be committing,
even the smallest and most innocuous change needs to be in its own branch
so that it can be reviewed (which we discuss below).


## Pull requests  {#rse-cmdline-git-pull-requests}

*FIXME: This lesson is from [UW-Madison](https://uw-madison-datascience.github.io/git-novice-custom/10-pull-requests/)
and therefore doesn't quite match the storyline of the other lessons.*

Pull requests are a great way to collaborate with others using github.
Instead of making changes directly to a repository, you can suggest changes via a pull request.
This can be useful if you don't have permission to modify a repository directly or
you want someone else to review your changes.

To be more specific, a pull request is essentially a marker saying,
"Someone would like to merge branch A into branch X".
The pull request does *not* contain the changes:
instead,
it points at two branches,
so that if either branch is changed,
the differences displayed are always up to date.

FIXME: figure

Pull requests can be created between two branches in a single repository,
or between branches of different repositories.
The latter is common in projects with many contributors:
each contributor works in a branch in their own [fork](glossary.html#fork) of the repository,
and when they're done,
they create a pull request offering to merge their changes into the `master` branch
of the original repository.
In order to update their own repository,
they pull changes from the original:

FIXME: figure

A pull request can store more than the location of the source and destination branch.
In particular,
it can store comments that people have made about the proposed merge.
GitHub and other [forges](glossary.html#forge) allow users to add comments on the pull request as a whole,
or on particular lines,
and can mark old comments as out of date if the lines of code the comment is attached to are updated.

To see this all in action,
let's go ahead and work on the `countries` repository together.
Open the github link for the `countries` repo provided by the instructor 
in your browser window.

*TODO: Figure - Upstream repo [../fig/github_screenshot_upstream_repo.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_upstream_repo.png)*

> **Repo owner differences**
>
> You may have noticed that the `countries` repo in this lesson's pictures 
> is owned by the 'McMahonLab' organization and this doesn't match
> the address you were given.
> This is to be expected because this will differ depending on 
> what organization your instructor used to setup the `countries` repo.
> 
> You will also see your username where the 'sstevens2' is in the pictures.
> 

Once at the `countries` repo, click the **Fork** button which can be found
in the upper right hand conner of the window. 
Forking the repository makes us each our own copy of the repo in our github 
account which we can edit.

*TODO: Figure - Upstream Forking [../fig/github_screenshot_upstream_forking.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_upstream_forking.png)*

Next we need to get this repo on our local computer and
setup connections from our computer to both our forked version 
and the authoritative version we forked it from.

First we will **clone** the repo from our forked version.
The clone command does two things:

1. Copies the repo to your local computer
2. Sets up a remote called 'origin' between your computer and the github repo

Copy the web address for your forked version of repo 
(from the web address line or click 'Clone and download' and copy that).

*TODO: Figure - Clone Origin [../fig/github_screenshot_cloneOrigin.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_cloneOrigin.png)*

In terminal or Gitbash, navigate to a folder you'd like to hold this repo,
we will place it on our `Desktop`.
Once there you can use the `clone` command with the link you copied as the first argument.

```shell
$ cd ~/Desktop
$ git clone https://github.com/USERNAME/countries.git
```

> **Why does the command above say 'USERNAME'?**
>
> So that we can't copy the command above and accidentally clone someone else's
> version of countries to our computer, the command above uses the placeholder
> 'USERNAME' where you should put your own username if your copied from above
> instead of copying the link from your browser and pasting it into the command.

```text
Cloning into 'countries'...
remote: Counting objects: 6, done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0
Unpacking objects: 100% (6/6), done.
```

Next we will set up a connection or **remote** to the authoritative repository 
(the original version given to you by your instructor).
In your browser, you can go back this repo by clicking on the link that says 'forked from'
in the upper left hand corner, under your username and repo name.

Copy the web address for this repo 
(from the web address line or click the 'clone and download' and copy that).

*TODO: Figure - Upstream Repo [../fig/github_screenshot_upstream_repo.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_upstream_repo.png)*

Then back in your terminal, navigate into the cloned repo and add the remote 
connection to this repository.
For this command we must give the remote a different nickname, 
where our original remote is 'origin'
this new remote will be called 'upstream'.
You could give it a different nickname but 'upstream' is a common nickname for
the authoritative repository.

```shell
$ cd countries
$ git remote add upstream https://github.com/INSTRUCTOR-GIVEN/countries.git
```

> **If you tried copying the command above...**
>
> You will have to replace 'INSTRUCTOR-GIVEN' with the site your instructor
> indicated at the beginning of this lesson. This will vary depending
> on how your instructor set up for this lesson.

At anytime you can see the remote connections your repo has using the following command:

```shell
$ git remote -v
```

```text
origin	https://github.com/USERNAME/countries.git (fetch)
origin	https://github.com/USERNAME/countries.git (push)
upstream	https://github.com/INSTRUCTOR-GIVEN/countries.git (fetch)
upstream	https://github.com/INSTRUCTOR-GIVEN/countries.git (push)
```

Now that we have this setup done we will be able to suggest 
changes to this repo using a pull request.
Each person will add a new file with info about a new country in it.

The instructor will now add a single file to the repository containing 
information about the the United States.

Next, we will update our local version of the repo to include the new file.
We use a command called `pull` to bring these changes to our local repository.
We must specify the remote and branch we want to pull from, in this case the 
`upstream` remote's `master` branch.

```shell
$ git pull upstream master
```

Now your local version of the repo is updated but our forked version of the 
repo is not yet up to date.
You can reload your fork in github and see it does not contain the new 
`united_states.txt` file.
Now we need to update our forked version.
To do so we can `push` the changes in our local version to the master branch of our fork, 
called 'origin'.

```shell
$ git push origin master
```

Now let's each add a new country to the repository.
First let's make a new branch to work on.  This will keep our 'master' version
in sync with the authoritative version of the repository.
We can name our branch descriptively after the country we will be adding.
Mine will be `addFrance` since I'll be working with France.
Please pick a different country and shout it out (or add it to the etherpad) 
so no one else chooses the same one.
We will create the branch and switch into in one step 
as we learned earlier in the branching lesson.

```shell
$ git checkout -b addFrance
```

```text
Switched to a new branch 'addFrance'
```

Finally before we proceed to adding the new file, we will double 
check that we are on the right branch.

```text
$ git branch
```

```text
* addFrance
  master
```

Next we will copy `united_states.txt` and change the name to the name of our chosen country.
Then we can use nano to edit the contents to reflect the info of your chosen country.  
Hint: You may need to do some internet searching to fill in the information.

```shell
$ cp united_states.txt france.txt
$ nano france.txt
$ cat france.txt
```

```text
Population: 66,991,000
Capital: Paris
```

Next let's add and commit the changes to the repo.

```shell
$ git add france.txt
$ git commit -m "Added file on france"
```

```text
[addFrance 79a312a] Added file on france
 1 file changed, 2 insertions(+), 2 deletions(-)
```

In some cases we may not have permission to push changes directly to the 
upstream/authoritative repo or we might like our changes to be reviewed regardless 
of permissions, so we'll create a `pull request`. 
A `pull request` is a **request** for a member of the upstream repository to **pull** 
our changes into the upstream repository from a `fork`, allowing them to request further 
changes/improvements and make comments on the changes before doing so. 
In order to create a `pull request`, we must push our new branch containing the
 changes we'd like to submit to the remote linked to our fork, `origin`, on GitHub.

```shell
$ git push origin addFrance
```

```text
Counting objects: 4, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 783 bytes | 0 bytes/s, done.
Total 4 (delta 3), reused 0 (delta 0)
remote: Resolving deltas: 100% (3/3), completed with 3 local objects.
To https://github.com/USERNAME/countries.git
   2037539..79a312a  addFrance -> addFrance
```

Next go to your forked github version of the repo and reload the page.
You won't see the new file added in the list of files but you will see 
that you recently pushed a new branch to the repository.

*TODO: Figure - Add France [../fig/github_screenshot_origin_master_addFrance.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_origin_master_addFrance.png)*


If you wish to view your new branch you can click on the 'Branch' drop down menu
and select that branch.

*TODO: Figure - Switch Branch [../fig/github_screenshot_switch_github_branch.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_switch_github_branch.png)*

Then you should be able to view the files and commits in that branch.

*TODO: Figure - Add France [../fig/github_screenshot_origin_master_addFrance.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_origin_master_addFrance.png)*

Github already suspects that we are going to want to make a pull request so we can click
the 'Compare & pull request' button to start a new pull request.

*TODO: Figure - Pull Request (Part 1) [../fig/github_screenshot_makingPR1.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_makingPR1.png)*

The base fork should be the upstream/authoritative version's master branch and then 
the head fork should be the new branch of our fork.
You can add more information into the comment section if there is anything you'd like 
to add for the person who reviews your suggestion.
Then you can click the 'create pull request button' to submit the pull request.

*TODO: Figure - Pull Request (Part 2) [../fig/github_screenshot_makingPR2.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_makingPR2.png)*

Now someone with privileges to the upstream repo can review it, give comments and
suggestions, and merge it into the upstream version.
In our pull request they can see any messages we left or click and look at the commits that were made and see the files changed.

Our collaborator reviewing the pull request noticed that 
we forgot to add the largest city so let's add it and update our pull request.

```shell
$ nano france.txt
$ cat france.txt
```

```text
Population: 66,991,000
Capital: Paris
Largest City: Paris
```

Next we will add and commit these changes.
Then we can push them to our fork of the repo.

```shell
$ git add france.txt
$ git commit -m "Added largest city to france file"
$ git push origin addFrance
```

```text
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 387 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/USERNAME/countries.git
   31aa2e3..609acfe  addFrance -> addFrance
```

If we reload the pull request, we'll see that the new commit was added to the 
pull request and the changes have been automatically updated.
New commits pushed to the same branch are included in the previous pull request.
If you want to suggest changes separately you need to make separate branches but 
if you want the changes to be considered together you should put them in the same branch.

*TODO: Figure - New Commit [../fig/github_screenshot_after_new_commit.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_after_new_commit.png)*

When working with others we might encounter the conflicts, which we
learned about earlier in branches.  Let's practice resolving conflicts when working
collaboratively.

We will continue to work in the `addFrance` branch from before and check we are
in that branch before we start.


```shell
$ git branch
```

```text
* addFrance
  master
```

Next we will each add our country to the existing `README.md` file in the repository in the line directly following the `Countries:` line.

```shell
$ nano README.md
$ cat README.md
```

```text
# countries
Sandbox for learning PR's in Software Carpentry workshop

Countries:
France
```

Next we need to add, commit, and push these requests to our existing pull request.

```shell
$ git add README.md
$ git commit -m "Added France to list of countries in README"
```

```text
[addFrance 66d7ebf] Added France to list of countries in README
 1 file changed, 1 insertions(+), 1 deletions(-)
```

```shell
$ git push origin addFrance
```

```text
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 376 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To https://github.com/USERNAME/countries.git
   609acfe..66d7ebf  addFrance -> addFrance
```

Now if we reload the page we had a pull request we notice that our `addFrance`
branch is conflicting with upstream's `master` branch.
This is because someone else edited the same line of the `README.md` file by 
adding 'United States' where we added 'France'.

*TODO: Figure - Conflicting PR [../fig/github_screenshot_conflicting_PR.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_conflicting_PR.png)*

In this case, it is possible to resolve this conflict in github by 
clicking the 'Resolve Conflicts' button.
However, we will reuse the skills we learned earlier to resolve this conflict locally,
as we did in our branching conflict.

First we need to pull down the changes from upstream's `master` branch into our
`addFrance` branch.

```shell
$ git pull upstream master
```

```text
From https://github.com/McMahonLab/countries
 * branch            master     -> FETCH_HEAD
Auto-merging README.md
CONFLICT (content): Merge conflict in README.md
Automatic merge failed; fix conflicts and then commit the result.
```

From the conflict error message we can see the conflict is in `README.md` or by running `git status` and seeing the 'both modified' status.

```shell
$ git status
```

```text
On branch addFrance
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

	both modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")
```

Now we will resolve the conflict by editing the `README.md` file to contain both 
'United States' and 'France' and none of the additional lines git added to
indicate conflict

```shell
$ nano README.md
$ cat README.md
```

```text
# countries
Sandbox for ComBEE github workshop on PR's

Countries:
France
United States
```

Then we add and commit our resolved conflict.

```shell
$ git add README.md
$ git commit -m "Resolved conflict in readme w two countries"
```

```text
[addFrance 912317b] Resolved conflict in readme w two countries
```

Finally we can update the pull request by pushing these changes to our github 
fork of the repository.

```shell
$ git push origin addFrance
```

```text
git push origin addFrance
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 732 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 1 local object.
To https://github.com/USERNAME/countries.git
   66d7ebf..912317b  addFrance -> addFrance
```

Now if we reload our browser we will see that the new commit is in the pull 
request and it has no conflicts with the base branch.

*TODO: Figure - Resolved Conflict [../fig/github_screenshot_resolved_PR_conflict.png](https://github.com/UW-Madison-DataScience/git-novice-custom/tree/gh-pages/fig/github_screenshot_resolved_PR_conflict.png)*

Now the owner/administrator/manager of the authoritative repo can review our pull requests and decide to incorporate them.



## Exercises {#rse-cmdline-git-exercises}

### Creating a repository

**Places to Create Git Repositories**

Along with tracking information about planets (the project we have already created), 
Dracula would also like to track information about moons.
Despite Wolfman's concerns, Dracula creates a `moons` project inside his `planets` 
project with the following sequence of commands:

```shell
$ cd ~/Desktop   # return to Desktop directory
$ cd planets     # go into planets directory, which is already a Git repository
$ ls -a          # ensure the .git sub-directory is still present in the planets directory
$ mkdir moons    # make a sub-directory planets/moons
$ cd moons       # go into moons sub-directory
$ git init       # make the moons sub-directory a Git repository
$ ls -a          # ensure the .git sub-directory is present indicating we have created a new Git repository
```

Is the `git init` command, run inside the `moons` sub-directory, required for 
tracking files stored in the `moons` sub-directory?
 
> *Solution*
>
> No. Dracula does not need to make the `moons` sub-directory a Git repository 
> because the `planets` repository will track all files, sub-directories, and 
> sub-directory files under the `planets` directory.  Thus, in order to track 
> all information about moons, Dracula only needed to add the `moons` sub-directory
> to the `planets` directory.
> 
> Additionally, Git repositories can interfere with each other if they are "nested":
> the outer repository will try to version-control
> the inner repository. Therefore, it's best to create each new Git
> repository in a separate directory. To be sure that there is no conflicting
> repository in the directory, check the output of `git status`. If it looks
> like the following, you are good to go to create a new repository as shown
> above:
>
> ```shell
> $ git status
> ```
>
> ```text
> fatal: Not a git repository (or any of the parent directories): .git
> ```


**Correcting `git init` Mistakes**

Wolfman explains to Dracula how a nested repository is redundant and may cause confusion
down the road. Dracula would like to remove the nested repository. How can Dracula undo 
his last `git init` in the `moons` sub-directory?

> *Background*
> 
> Removing files from a git repository needs to be done with caution. To remove files from the working tree and not from your working directory, use
> 
> ```shell
> $ rm filename
> ```
> 
> The file being removed has to be in sync with the branch head with no updates.
> If there are updates, the file can be removed by force by using the `-f` option.
> Similarly a directory can be removed from git using `rm -r dirname` or `rm -rf dirname`.
>
> *Solution - USE WITH CAUTION*
>
> Git keeps all of its files in the `.git` directory.
> To recover from this little mistake, Dracula can just remove the `.git`
> folder in the moons subdirectory by running the following command from inside the `planets` directory:
>
> ```shell
> $ rm -rf moons/.git
> ```
>
> But be careful! Running this command in the wrong directory, will remove
> the entire Git history of a project you might want to keep.
> Therefore, always check your current directory using the command `pwd`.


### Tracking changes

**Committing Changes to Git**

Which command(s) below would save the changes of `myfile.txt`
to my local Git repository?

1. ```shell
   $ git commit -m "my recent changes"
   ```

2. ```shell
   $ git init myfile.txt
   $ git commit -m "my recent changes"
   ```

3. ```shell
   $ git add myfile.txt
   $ git commit -m "my recent changes"
   ```

4. ```shell
   $ git commit -m myfile.txt "my recent changes"
   ```

> *Solution*
>
> 1. Would only create a commit if files have already been staged.  
> 2. Would try to create a new repository.  
> 3. Is correct: first add the file to the staging area, then commit.  
> 4. Would try to commit a file "my recent changes" with the message myfile.txt.  


**Committing Multiple Files**

The staging area can hold changes from any number of files
that you want to commit as a single snapshot.

1. Add some text to `mars.txt` noting your decision
to consider Venus as a base

2. Create a new file `venus.txt` with your initial thoughts
about Venus as a base for you and your friends

3. Add changes from both files to the staging area,
and commit those changes.

> *Solution*
>
> First we make our changes to the `mars.txt` and `venus.txt` files:  
> ```shell
> $ nano mars.txt
> $ cat mars.txt
> ```
>
> ```text
> Maybe I should start with a base on Venus.
> ```
>
> ```shell
> $ nano venus.txt
> $ cat venus.txt
> ```
>
> ```text
> Venus is a nice planet and I definitely should consider it as a base.
> ```
>
> Now you can add both files to the staging area. We can do that in one line:
>
> ```shell
> $ git add mars.txt venus.txt
> ```
> 
> Or with multiple commands:  
>
> ```shell
> $ git add mars.txt
> $ git add venus.txt
> ```
>
> Now the files are ready to commit. You can check that using `git status`. If you are ready to commit use:
>
> ```shell
> $ git commit -m "Write plans to start a base on Venus"
> ```
> ```text
> [master cc127c2]
> Write plans to start a base on Venus
> 2 files changed, 2 insertions(+)
> create mode 100644 venus.txt
> ```

**`bio` Repository**

* Create a new Git repository on your computer called `bio`.  
* Write a three-line biography for yourself in a file called `me.txt`, commit your changes. 
* Modify one line, add a fourth line. 
* Display the differences between its updated state and its original state.  

> *Solution*
>
> If needed, move out of the `planets` folder:
>
> ```shell
> $ cd ..
> ```
>
> Create a new folder called `bio` and 'move' into it:
>
> ```shell
> $ mkdir bio
> $ cd bio
> ```
>
> Initialise git:
>
> ```shell
> $ git init
> ```
>
> Create your biography file `me.txt` using `nano` or another text editor.
> Once in place, add and commit it to the repository:
>
> ```shell
> $ git add me.txt
> $ git commit -m'Adding biography file'
> ```
>
> Modify the file as described (modify one line, add a fourth line).
> To display the differences
> between its updated state and its original state, use `git diff`:
>
> ```shell
> $ git diff me.txt
> ```

### Ignoring things

**Ignoring Nested Files**

Given a directory structure that looks like:

```shell
results/data
results/plots
```

How would you ignore only `results/plots` and not `results/data`?

> *Solution*
>
> If you only want to ignore the contents of
> `results/plots`, you can change your `.gitignore` to ignore
> only the `/plots/` subfolder by adding the following line to
> your .gitignore:
> 
> ```text
> results/plots/
> ```
>
> This line will ensure only the contents of `results/plots` is ignored, and
> not the contents of `results/data`.
> 
> As with most programming issues, there
> are a few alternative ways that one may ensure this ignore rule is followed.
> The "Ignoring Nested Files: Variation" exercise has a slightly
> different directory structure
> that presents an alternative solution.
> Further, the discussion page has more detail on ignore rules.


**Including Specific Files**

How would you ignore all `.dat` files in your root directory except for `final.dat`?

Hint: Find out what `!` (the exclamation point operator) does.

> *Solution*
> 
> You would add the following two lines to your .gitignore:
> 
> ```text
> *.dat           # ignore all data files
> !final.dat      # except final.data
> ```
>
> The exclamation point operator will include a previously excluded entry.
> 
> Note also that because you've previously committed `.dat` files in this
> lesson they will not be ignored with this new rule. Only future additions
> of `.dat` files added to the root directory will be ignored.


### Remotes in GitHub

**GitHub GUI**

Browse to your `planets` repository on GitHub.
Under the Code tab, find and click on the text that says "XX commits" (where "XX" is some number).
Hover over, and click on, the three buttons to the right of each commit.
What information can you gather/explore from these buttons?
How would you get that same information in the shell?

> *Solution*
>
> The left-most button (with the picture of a clipboard) copies the full identifier of the commit 
> to the clipboard. In the shell, ```git log``` will show you the full commit identifier for each 
> commit.
> 
> When you click on the middle button, you'll see all of the changes that were made in that 
> particular commit. Green shaded lines indicate additions and red ones removals. In the shell we 
> can do the same thing with ```git diff```. In particular, ```git diff ID1..ID2``` where ID1 and 
> ID2 are commit identifiers (e.g. ```git diff a3bf1e5..041e637```) will show the differences 
> between those two commits.
> 
> The right-most button lets you view all of the files in the repository at the time of that 
> commit. To do this in the shell, we'd need to checkout the repository at that particular time. 
> We can do this with ```git checkout ID``` where ID is the identifier of the commit we want to 
> look at. If we do this, we need to remember to put the repository back to the right state 
> afterwards!


**GitHub Timestamp**

Create a remote repository on GitHub. Push the contents of your local
repository to the remote. Make changes to your local repository and push these
changes. Go to the repo you just created on GitHub and check the
timestamps of the files. How does GitHub record times, and why?

> *Solution*
>
> GitHub displays timestamps in a human readable relative format (i.e. "22 hours ago" or "three 
> weeks ago"). However, if you hover over the timestamp, you can see the exact time at which the 
> last change to the file occurred.


**Push vs. Commit**

In this lesson, we introduced the "git push" command.
How is "git push" different from "git commit"?

> *Solution*
>
> When we push changes, we're interacting with a remote repository to update it with the changes 
> we've made locally (often this corresponds to sharing the changes we've made with others). 
> Commit only updates your local repository.


**GitHub License and README files**

In this section we learned about creating a remote repository on GitHub, but when you initialized 
your GitHub repo, you didn't add a README.md or a license file. If you had, what do you think 
would have happened when you tried to link your local and remote repositories?

> *Solution*
>
> In this case, we'd see a merge conflict due to unrelated histories. When GitHub creates a 
> README.md file, it performs a commit in the remote repository. When you try to pull the remote 
> repository to your local repository, Git detects that they have histories that do not share a 
> common origin and refuses to merge.
>
> ```shell
> $ git pull origin master
> ```
>
> ```text
> warning: no common commits
> remote: Enumerating objects: 3, done.
> remote: Counting objects: 100% (3/3), done.
> remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
> Unpacking objects: 100% (3/3), done.
> From https://github.com/vlad/planets
>  * branch            master     -> FETCH_HEAD
>  * [new branch]      master     -> origin/master
> fatal: refusing to merge unrelated histories
> ```
>
> You can force git to merge the two repositories with the option `--allow-unrelated-histories`. 
> Be careful when you use this option and carefully examine the contents of local and remote 
> repositories before merging.
>
> ```shell
> $ git pull --allow-unrelated-histories origin master
> ```
> 
> ```text
> From https://github.com/vlad/planets
>  * branch            master     -> FETCH_HEAD
> Merge made by the 'recursive' strategy.
> README.md | 1 +
> 1 file changed, 1 insertion(+)
> create mode 100644 README.md
> ```


### Exploring history


**Recovering Older Versions of a File**

Jennifer has made changes to the Python script that she has been working on for weeks, and the
modifications she made this morning "broke" the script and it no longer runs. She has spent
~ 1hr trying to fix it, with no luck...

Luckily, she has been keeping track of her project's versions using Git! Which commands below will
let her recover the last committed version of her Python script called
`data_cruncher.py`?

1. `$ git checkout HEAD`

2. `$ git checkout HEAD data_cruncher.py`

3. `$ git checkout HEAD~1 data_cruncher.py`

4. `$ git checkout <unique ID of last commit> data_cruncher.py`

5. Both 2 and 4

> *Solution*
>
> The answer is (5)-Both 2 and 4. 
> 
> The `checkout` command restores files from the repository, overwriting the files in your working 
> directory. Answers 2 and 4 both restore the *latest* version *in the repository* of the file 
> `data_cruncher.py`. Answer 2 uses `HEAD` to indicate the *latest*, whereas answer 4 uses the 
> unique ID of the last commit, which is what `HEAD` means. 
> 
> Answer 3 gets the version of `data_cruncher.py` from the commit *before* `HEAD`, which is NOT 
> what we wanted.
> 
> Answer 1 can be dangerous! Without a filename, `git checkout` will restore **all files** 
> in the current directory (and all directories below it) to their state at the commit specified. 
> This command will restore `data_cruncher.py` to the latest commit version, but it will also 
> restore *any other files that are changed* to that version, erasing any changes you may 
> have made to those files!
> As discussed above, you are left in a *detached* `HEAD` state, and you don't want to be there.


**Reverting a Commit**

Jennifer is collaborating on her Python script with her colleagues and
realizes her last commit to the project's repository contained an error and
she wants to undo it.  `git revert [erroneous commit ID]` will create a new 
commit that reverses Jennifer's erroneous commit. Therefore `git revert` is
different to `git checkout [commit ID]` because `git checkout` returns the
files within the local repository to a previous state, whereas `git revert`
reverses changes committed to the local and project repositories.  
Below are the right steps and explanations for Jennifer to use `git revert`,
what is the missing command?

1. `________ # Look at the git history of the project to find the commit ID`

2. Copy the ID (the first few characters of the ID, e.g. 0b1d055).

3. `git revert [commit ID]`

4. Type in the new commit message.

5. Save and close


**Understanding Workflow and History**

What is the output of the last command in

```
$ cd planets
$ echo "Venus is beautiful and full of love" > venus.txt
$ git add venus.txt
$ echo "Venus is too hot to be suitable as a base" >> venus.txt
$ git commit -m "Comment on Venus as an unsuitable base"
$ git checkout HEAD venus.txt
$ cat venus.txt #this will print the contents of venus.txt to the screen
```

1. ```text
   Venus is too hot to be suitable as a base
   ```

2. ```
   Venus is beautiful and full of love
   ```

3. ```
   Venus is beautiful and full of love
   Venus is too hot to be suitable as a base
   ```

4. ```
   Error because you have changed venus.txt without committing the changes
   ```

> *Solution*
>
> The answer is 2. 
>  
> The command `git add venus.txt` places the current version of `venus.txt` into the staging area. 
> The changes to the file from the second `echo` command are only applied to the working copy, 
> not the version in the staging area.
>  
> So, when `git commit -m "Comment on Venus as an unsuitable base"` is executed, 
> the version of `venus.txt` committed to the repository is the one from the staging area and
> has only one line.
>   
> At this time, the working copy still has the second line (and 
> `git status` will show that the file is modified). However, `git checkout HEAD venus.txt` 
> replaces the working copy with the most recently committed version of `venus.txt`.
>   
>  So, `cat venus.txt` will output 
>  
>  ```text
>  Venus is beautiful and full of love.
>  ```


**Checking Understanding of `git diff`**

Consider this command: `git diff HEAD~9 mars.txt`. What do you predict this command
will do if you execute it? What happens when you do execute it? Why?

Try another command, `git diff [ID] mars.txt`, where [ID] is replaced with
the unique identifier for your most recent commit. What do you think will happen,
and what does happen?


**Getting Rid of Staged Changes**

`git checkout` can be used to restore a previous commit when unstaged changes have
been made, but will it also work for changes that have been staged but not committed?
Make a change to `mars.txt`, add that change, and use `git checkout` to see if
you can remove your change.


**Explore and Summarize Histories**

Exploring history is an important part of Git, often it is a challenge to find
the right commit ID, especially if the commit is from several months ago.

Imagine the `planets` project has more than 50 files.
You would like to find a commit with specific text in `mars.txt` is modified.
When you type `git log`, a very long list appeared,
How can you narrow down the search?

Recall that the `git diff` command allow us to explore one specific file,
e.g. `git diff mars.txt`. We can apply a similar idea here.

```shell
$ git log mars.txt
```

Unfortunately some of these commit messages are very ambiguous e.g. `update files`.
How can you search through these files?

Both `git diff` and `git log` are very useful and they summarize a different part of the history 
for you.
Is it possible to combine both? Let's try the following:

```shell
$ git log --patch mars.txt
```

You should get a long list of output, and you should be able to see both commit messages and 
the difference between each commit.

Question: What does the following command do?

```shell
$ git log --patch HEAD~9 *.txt
```


### Branches

TODO.


### Pull requests

**Add new country file and make additional PR**

* Starting in the master branch make a new branch
* Copy other country file into a new country
* Edit the file to include info on the new country
* Add and commit this new file
* Push the new changes to github

> *Solution*
> 
> ```shell
> $ git checkout master
> $ git checkout -b addItaly
> $ cp united_states.txt italy.txt
> $ nano italy.txt #Add the right info into the file
> $ git add italy.txt
> $ git commit -m "Added file on Italy"
> $ git push origin addItaly
> ```


## Key Points {#rse-cmdline-git-keypoints}

```{r, child="keypoints/rse-cmdline-git.md"}
```

```{r, child="./links.md"}
```


