# Command Line Programs in Python {#rse-py-scripting}

The Jupyter Notebook, PyCharm and other interactive tools
are great for prototyping code and exploring data,
but in many cases you will ultimately want to take the code you've developed
using those tools and apply it to thousands of data files, 
run it with many different parameters,
and/or combine it with other programs in a data analysis pipeline. 
To effectively perform these tasks,
it is often necessary to turn the code you've developed into a standalone program 
that can be run from the Unix shell,
just like other command-line tools.

In this chapter we take the code we developed earlier (TODO: Link)
and turn it into a Python script (i.e. a command line program written in Python).

## How are command-line scripts structured? {#rse-py-scripting-template}

In general,
the first thing that gets added to any Python script is the following:

```python
if __name__ == '__main__':
    main()
```

The reason we need these two lines of code
is to differentiate between running a Python file as a standalone program
and importing it as a module. 
When you import a Python file as a module,
the `__name__` variable is automatically set to the name of the file
(e.g. when importing script.py, `__name__` is `script`).
When running a Python file as a standalone program,
`__name__` is always set to `__main__`.
This means that we can separate the two cases above by checking the value of `__name__`.
When the Python file is running as a standalone program,
we want to execute its main functionality.
Conventionally, this functionality is defined inside a function named `main()`,
but you could call this function whatever you prefer.

The next thing you'll need is a library to parse the command line for input arguments.
The most widely used option is 
[argparse](https://docs.python.org/3/library/argparse.html).

Putting those together,
let's create a basic python script called `script_template.py` 
by opening our favourite text editor and entering the following:

```python
import argparse

#
# All your functions (that will be called by main()) go here.
#

def main(inargs):
    """Run the program."""

    print('Input file: ', inargs.infile)
    print('Output file: ', inargs.outfile)


if __name__ == '__main__':

    description='Print the input arguments to the screen.'
    parser = argparse.ArgumentParser(description=description)
    
    parser.add_argument("infile", type=str, help="Input file name")
    parser.add_argument("outfile", type=str, help="Output file name")

    args = parser.parse_args()            
    main(args)
```

By running `script_template.py` at the command line
we'll see that `argparse` handles all the input arguments:

```shell
$ python script_template.py in.csv out.png
```

```text
Input file:  in.csv
Output file:  out.png
```

It also generates help information for the user:

```shell
$ python script_template.py -h
```

```text
usage: script_template.py [-h] infile outfile

Print the input arguments to the screen.

positional arguments:
  infile      Input file name
  outfile     Output file name

optional arguments:
  -h, --help  show this help message and exit
```

and issues errors when users give the program invalid arguments:

```shell
$ python script_template.py in.csv
```

```text
usage: script_template.py [-h] infile outfile
script_template.py: error: the following arguments are required: outfile
```

## Where should I put my code? {#rse-py-scripting-code}

Using this template as a starting point,
we can add the functions we developed previously to a script called...

TODO: In this section we will take the code developed in the novice book
and turn it into a Python script that can be executed at the command line.
See [this lesson](https://carpentrieslab.github.io/python-aos-lesson/04-cmdline/index.html)
for an example of this approach in action.

> **Code Reuse**
>
> In the novice lessons,
> we learned how to reuse (rather than cut and paste)
> code by defining functions (TODO: link to relevant novice sections).
> In order to use those functions in other python notebooks/scripts,
> we saw that we can save them in a file (called a module)
> that can be imported (TODO: link to relevant novice sections).
> In this chapter, we've seen that we can go one step further
> and run our Python code outside of a Python environment,
> by writing Python scripts that can be executed at the command line.

## How can I write useful error messages? {#rse-py-scripting-error-messages}

The error message shown in Figure \@ref(fig:rse-py-scripting-error-message)(#FIG) is not helpful:

```{r rse-py-scripting-error-message, echo=FALSE, fig.cap="An Unhelpful Error Message"}
knitr::include_graphics("figures/rse-py-scripting/error-message.png")
```

{% include figure.html id="f:docs-error-message" src="error-message.png" caption="Error Message" %}

Neither is this:

```text
System.InvalidOperationException: Nullable object must have a value.
```

or this:

```text
I tried really hard but was unable to complete your request.
You probably need to talk to a human - have you tried calling Dave?
```

Error messages are often the first thing people actually read about a piece of software
(or possibly the second if they had to install it themselves),
so they should therefore be the most carefully written documentation for that software.
A quick web search for "writing good error messages" turns up hundreds of hits,
but recommendations are often more like gripes than solid guidelines
and are usually not backed up by evidence.
What research there is gives us the following rules @Beck2016:

1.  Do not tell the user what the program did that caused the problem,
    but what the user did.
    Putting it another way,
    the message shouldn't state the effect of the error,
    it should state the cause.   

2.  Be spatially correct,
    i.e.,
    point at the actual location of the error.
    Few things are as frustrating as being pointed at line 28
    when the problem is really on line 35.

3.  Do not provide tips or potential solutions.
    In most languages it is not possible to determine what the actual error is from the message with 100% certainty.
    Therefore it is better to give an as-specific-as-possible message on what went wrong without offering guidance on fixing it.
    Tips and hints could be provided by a different tool,
    but they should be based on the error message and not part of it.

4.  Be as specific as possible without ever being (or seeming) wrong:
    from a user's point of view,
    "file not found" is very different from "don't have permissions to open file" or "file is empty".

5.  Write for your audience's level of understanding.
    For example, error messages should never use programming terms more advanced than
    those you would use to describe the code the user wrote.

6.  Do not blame the user, and do not use words like fatal, illegal, etc.
    The former can frustrate—in many cases, "user error" actually isn't—and
    the latter can make people worry that the program has damaged their data,
    their computer,
    or their reputation.

7.  Do not try to make the computer sound like a human being.
    In particular, avoid humor:
    very few jokes are funny on the dozenth re-telling,
    and most users are going to see error messages at least that often.

8.  Use a consistent vocabulary.
    This rule can be hard to enforce when error messages are written by several different people,
    but putting them all in one module makes review easier.

That last suggestion deserves a little elaboration.
Most people write error messages directly in their code:

```python
try:
    # ...do something complicated...
except OSError as e:
    print('Unable to find or read file {}'.format(filename))
    sys.exit(1)
```

A better approach for large projects is to put all of the error messages in a catalog:

```python
ERROR_MESSAGES = {
    'cannot_read_file' : 'Unable to find or read file {}',
    'config_corrupted' : 'Configuration file {} corrupted',
    # ...more error messages...
}
```

and then only use messages from that catalog:

```python
from error_messages import ERROR_MESSAGES

try:
    # ...do something complicated...
except OSError as e:
    print(ERROR_MESSAGES['cannot_read_file'].format(filename))
    sys.exit(1)
```

Doing this makes it much easier to ensure that messages are consistent.
It also makes it much easier to give messages in the user's preferred language:

```python
ERROR_MESSAGES = {
    'en' : {
        'cannot_read_file' : 'Unable to find or read file {}',
        'config_corrupted' : 'Configuration file {} corrupted',
        # ...more error messages in English...
    },
    'fr' : {
        'cannot_read_file' : 'Impossible d'acceder au fichier {}',
        'config_corrupted' : 'Fichier de configuration {} corrompu',
        # ...more error messages in French...
    }
    # ...other languages...
}
```

The error report is then looked up as:

```python
ERROR_MESSAGES[user_language]['cannot_read_file']
```

where `user_language` is a two-letter code for the user's preferred language.

## Key Points {#rse-pyscripts-keypoints}

```{r, child="keypoints/rse-py-scripting.md"}
```

```{r, child="./links.md"}
```
